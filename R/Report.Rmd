---
title: "Statexpres's: Rapid Development with Mentalab Explore - Advanced Signal Exploration in Sleep EEG (statexpres.com/sleep)"
output:
  flexdashboard::flex_dashboard:
    storyboard: TRUE
    always_allow_html: yes
  pdf_document:
    classoption: landscape
    documentclass: ar-1col
    header-includes: \usepackage{fancyhdr,tabu, courier,chngcntr,longtable, graphicx,float,natbib,geometry}
    keep_tex: TRUE
    fig_caption: yes
    number_sections: yes
    always_allow_html: yes
runtime: shiny
---

<style>
  .storyboard-nav .sbframelist {
        margin: 0 auto;
        width: 94%;
        height: 90px;
        overflow: hidden;
        text-shadow: none;
        margin-bottom: 3px;
        margin-top: 3px;
  }
  .storyboard-nav .sbnext, .storyboard-nav .sbprev {
        float: left;
        width: 20px;
        height: 20px;
        font-size: 20px;
  }
</style>

```{r dependencies, include=FALSE}
## Create Folders and source them
## sudo apt-get install tk-dev
## sudo apt-get install fftw-dev
## sudo apt-get install libcgal-dev libglu1-mesa-dev libglu1-mesa-dev

reticulate::use_python(reticulate::py_config()[[1]],required = T)
library(reticulate)
# mainDir<-getwd()
# create_folder<-function(x)ifelse(!dir.exists(file.path(getwd(), x)), dir.create(file.path(getwd(), x)), FALSE)
# create_folder('Data')
# create_folder('Report')
# create_folder('Plots')
# create_folder('EDF')
loadpackage<-function(x){
  for(i in x){
    if(!(i %in% rownames(installed.packages()))){
    eval(parse(text=paste0("install.packages(\"",i,"\", repos=\'http://cran.us.r-project.org\')")))
    eval(parse(text=paste0("library(\"",i,"\")")))}
    else{eval(parse(text=paste0("library(\"",i,"\")")))}
  }
}
## Load install R packages
loadpackage(c("plyr","dplyr","ggplot2","knitr","broom","ggfortify","kableExtra","xts","eegUtils","dlm","forecast","signal","rmarkdown","plotly","visNetwork","Rssa","RHRV","data.table","DT","shinyTime","shinyWidgets","dygraphs","ggplotify","cowplot","tidyr"))
demoMode=F
# set default code-chunk parameters
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE, 
                      fig.align = 'center', fig.pos = 'htbp', results = 'asis')
options(scipen = 999)# no exponentials-plain values
options(shiny.maxRequestSize=5000*1024^2)#Max Upload Size
options(shiny.Trace=T)
## Default output format (shiny-html first, statitic-Pdf later)
if(!is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))){
  outputoption<<-knitr::opts_knit$get("rmarkdown.pandoc.to")
}else{outputoption<<-"html"}
shiny_running = function()identical(rmarkdown::metadata$runtime, 'shiny')&outputoption!="latex"
if(!shiny_running()){
  reactiveValues<-function(...)list(...)
}
if(outputoption!="html"){
  if(outputoption!="latex"){
  mainDir<-getwd()
  }else{
    mainDir<-getwd()
    # mainDirsplit<-strsplit(mainDir,"/")[[1]]
    # mainDir<-paste(mainDirsplit[-length(mainDirsplit)],collapse="/")
    
  }
}else{
  if(outputoption=="html")
    mainDir<-"/srv/shiny-server/Test/"
    demoMode=T
    # mainDir<-"/home/sweiss/Mentalab/"
}

if(!shiny_running()){
  reactiveValues<-function(...)list(...)
}
```

```{r}
## Setup Python in Reticulate
#reticulate::repl_python()
# conda_create("final")
#use_condaenv("final")
# reticulate::repl_python()
# explorepy <- reticulate::import_from_path("explorepy",path="C:/Users/royde/Anaconda3/Lib/site-packages")
# visbrain<-reticulate::import("visbrain",delay_load = T)
# scipy <- reticulate::import("scipy",delay_load = T)
# numpy <- reticulate::import("numpy",delay_load = T)
#conda_install("MENTALAB", "explorepy")
```

```{r,define_functions}
reticulate::source_python(paste0(mainDir,"/EEG.py"))
source(paste0(mainDir,"/helpers.R"))
source(paste0(mainDir,"/ui.R"))
source(paste0(mainDir,"/fixed_frequency.R"))

findexg<-function(nodes,edges,pos){
  res=as.character(nodes[nodes$id %in% subset(edges,to==pos)$from& nodes$group %in% "physical","label"])
    res<-unique(c(res,as.character(nodes[nodes$id %in% subset(edges,from==pos)$to& nodes$group %in% "physical","label"])))                                           
    return(res)
}

findneighbors<-function(nodes,edges,nom,dir="both",g=NULL){
  if(dir=="both"){
    ids=nodes[nodes$label %in% nom,"id"]
    es=edges[edges$from %in% ids | edges$to %in% ids,]
    if(!is.null(g)){
      gnods=nodes[nodes$group %in% g,"id"]
      gedges=edges$id[(edges$from %in% gnods)|(edges$to %in% gnods)]
      redges=es[es$id %in% gedges,]
      res=unique(nodes[nodes$id %in% redges$from | nodes$id %in% redges$to,"label"])
      res=res[!(res %in% nom)]
    }else{
      res=unique(nodes[nodes$id %in% es$from | nodes$id %in% es$to,"label"])
      res=res[!(res %in% nom)]
    }
    # res=as.character(nodes[nodes$id %in% subset(edges,to==pos)$from & nodes$group %in% "physical","label"])
  }
  if(dir=="to"){
    ids=nodes[nodes$label %in% nom,"id"]
    es=edges[ edges$to %in% ids,]
    if(!is.null(g)){
      gnods=nodes[nodes$group %in% g,"id"]
      gedges=edges$id[(edges$from %in% gnods)]
      redges=es[es$id %in% gedges,]
      res=unique(nodes[ nodes$id %in% redges$from,"label"])
      res=res[!(res %in% nom)]
    }else{
      res=unique(nodes[nodes$id %in% es$from,"label"])
      res=res[!(res %in% nom)]
    }
  }
  if(dir=="from"){
    ids=nodes[nodes$label %in% nom,"id"]
    es=edges[edges$from %in% ids ,]
    if(!is.null(g)){
      gnods=nodes[nodes$group %in% g,"id"]
      gedges=edges$id[(edges$to %in% gnods)]
      redges=es[es$id %in% gedges,]
      res=unique(nodes[nodes$id %in% redges$to ,"label"])
      res=res[!(res %in% nom)]
    }else{
      res=unique(nodes[nodes$id %in% es$to ,"label"])
      res=res[!(res %in% nom)]
    }
  }
  if(length(res)==0){res=""}
  # res=as.character(nodes[nodes$id %in% subset(edges,to==pos)$from& nodes$group %in% "physical","label"])
  # res<-unique(c(res,as.character(nodes[nodes$id %in% subset(edges,from==pos)$to & 
  #                                        nodes$group %in% "physical","label"])))                                    
    return(res)
}

filter_value=function(nodes,edges,s){
  fn=nodes[nodes$label==s,"id"]
  fe=edges[edges$from==fn,"title"]
  res=strsplit(fe,":")
  res2=unlist(lapply(res,function(x)x[2]))
  res=unlist(lapply(res,function(x)x[1]))
  ## Making use of to is channel and from is filter
  if("High Pass" %in% res){
    n_f=length(edges[edges$to==fn,"title"])
    hf=rep(paste0("H:",res2[res %in% "High Pass"]),n_f)
  }else{
    n_f=length(edges[edges$to==fn,"title"])
    hf=rep(paste0("H:",0),n_f)
  }
  if("Low Pass" %in% res){
    n_f=length(edges[edges$to==fn,"title"])
    hf2=rep(paste0("L:",res2[res %in% "Low Pass"]),n_f)
  }else{
    n_f=length(edges[edges$to==fn,"title"])
    hf2=rep(paste0("L:",0),n_f)
  }
  if("Notch" %in% res){
    n_f=length(edges[edges$to==fn,"title"])
    hf3=rep(paste0("N:",res2[res %in% "Notch"]),n_f)
  }else{
    n_f=length(edges[edges$to==fn,"title"])
    hf3=rep(paste0("N:",0),n_f)
  }
    
  
  return(paste0(hf3,hf2,hf))
}


findrecons<-function(nodes,edges,pos){
  res=as.character(nodes[nodes$id %in% subset(edges,to==pos)$from& nodes$group %in% "Reconstruction","label"])
    res<-unique(c(res,as.character(nodes[nodes$id %in% subset(edges,from==pos)$to& nodes$group %in% "Reconstruction","label"])))                                           
    return(res)
}

findcluster<-function(nodes,edges,pos){
  res=as.character(nodes[nodes$id %in% subset(edges,to==pos)$from& nodes$group %in% "Cluster","label"])
    res<-unique(c(res,as.character(nodes[nodes$id %in% subset(edges,from==pos)$to& nodes$group %in% "Cluster","label"])))                                           
    return(res)
}

findcomponent<-function(nodes,edges,pos){
  res=as.character(nodes[nodes$id %in% subset(edges,to==pos)$from& nodes$group %in% "Components","label"])
    res<-unique(c(res,as.character(nodes[nodes$id %in% subset(edges,from==pos)$to& nodes$group %in% "Components","label"])))                                           
    return(res)
}

```


<!-- \lhead{MentaLab's Signal Evaluation \linebreak {\leftmark}  } -->

\clearpage
  
<!-- ### Signal Source -->

```{r,init_fixed}
# if(shiny_running()){
init.Date=Sys.time()
init.time=strftime(init.Date, format = "%H:%M")
base.nodes<<-data.frame(
  id = c(1:7),
  label=c("EEG","ECG","EOG","EMG","Notch","High Pass","Low Pass"),
  group=c(rep("biological",4),rep("digital",3)),stringsAsFactors = F)

# init.ExG=import_raw("/srv/shiny-server/UItest/EDF/Stefan W, 32 yo, Apnoe, no Medication_.edf")
# init.srate=init.ExG[["srate"]]
# init.ExG=round(data.frame(init.ExG[["signals"]]),0)
if(demoMode==F){
## A small converted data set
init.ExG<<-round(data.frame(fread(paste0(mainDir,"/Data/DATA003_eeg.csv"), header=T)[,-1])*1000*1000,0)
init.srate<<-250
init.channels<<-colnames(init.ExG)

base.nodes<<-data.frame(
  id = c(1:7),
  label=c("EEG","ECG","EOG","EMG","Notch","High Pass","Low Pass"),
  group=c(rep("biological",4),rep("digital",3)),stringsAsFactors = F)

init.nodes<<-update_nodes(base.nodes,init.ExG)
biosigs<-subset(init.nodes,group=="biological")
physigs<-subset(init.nodes,group=="physical")
digsigs<-subset(init.nodes,group=="digital")

init.edges=data.frame(from = physigs$id[5:8], to = biosigs$id[1])
init.edges<-rbind(init.edges,data.frame(from = physigs$id[1], to = biosigs$id[2]))
init.edges<-rbind(init.edges,data.frame(from = physigs$id[2:3], to = biosigs$id[3]))
init.edges<-rbind(init.edges,data.frame(from = physigs$id[4], to = biosigs$id[4]))
init.edges<-rbind(init.edges,data.frame(from = biosigs$id[1], to = digsigs$id[2:3]))
init.edges$id<-1:nrow(init.edges)
init.edges$title=""
init.edges$value=1


init.eeg.fits=findexg(init.nodes,init.edges,1)
init.ecg.fits=findexg(init.nodes,init.edges,2)
init.eog.fits=findexg(init.nodes,init.edges,3)
init.emg.fits=findexg(init.nodes,init.edges,4)

init.freq_filter.temp=freq_filter(init.ExG,init.srate,50,c(2,30),init.eeg.fits)
colnames(init.freq_filter.temp)<-paste0("Filtered",colnames(init.freq_filter.temp))
init.freq_filter<-as.xts(init.freq_filter.temp,
                         seq(as.POSIXct("2020-01-31 23:55:00"),
                             by=1/init.srate,
                             length=nrow(init.freq_filter.temp)))

init.bandpower<-rel_bp(init.freq_filter.temp[,5])
init.freq.bandpower<-as.xts((init.bandpower[,1:5]/init.bandpower[,6])*100,seq(as.POSIXct("2020-03-03 23:55:00"), by=30, length=nrow(init.bandpower)))

init.stages=data.frame(
  "Sleep State (W, S1, S2, S3, REM)"=c("W","S1","S2","S3","S2","S3"),
  "Time (xx:xx or xx:xx:xx)"=as.POSIXct(c(paste(as.Date(as.POSIXct("2020-01-31 23:55:00")),"23:55:00"), paste(as.Date(as.POSIXct("2020-01-31 23:55:00"))+1,c("00:08:00","00:30:00","01:02:00","01:28:00","01:46:00")))),
                       stringsAsFactors = F)

# init.stages=data.frame(
#   "Sleep State (W, S1, S2, S3, REM)"=c("W"),
#   "Time (xx:xx or xx:xx:xx)"=as.POSIXct("2020-03-03 23:55:00"),
#                        stringsAsFactors = F)

# init.stages=data.frame("Sleep State (W, S1, S2, S3, REM)"=c("W","S1","S2"),"Time (xx:xx or xx:xx:xx)"=c("00:08","00:30","01:02"),stringsAsFactors = F)

# init.stages=data.frame("Stage / Event" = rep("Stage",3),
#                        "Sleep State (W, S1, S2, S3, REM)"=c("W","S1","S2"),
#                        "Time (xx:xx or xx:xx:xx)"=c("00:08","00:30","01:02"),
#                        stringsAsFactors = F)

## For Visual Display only, optimization routine for quick display
init.orig.chan=init.freq_filter[,paste0("Filtered",init.eeg.fits)]
init.orig.ssa=init.orig.chan
init.orig.disp=init.orig.chan
init.disp=downsample(init.freq_filter[,paste0("Filtered",init.eeg.fits)],250*60)
init.resol=c(first(index(init.freq_filter)),last(index(init.freq_filter)))


## Singular Spectrum Analysis initial call
# tmp=round(downsample(window(init.freq_filter,start=first(index(init.freq_filter)),end=(first(index(init.freq_filter))+60*5)),10),6)
tmp=downsample(window(init.freq_filter,start=as.POSIXct("2020-01-31 23:55"),end=as.POSIXct("2020-01-31 23:58")),25)
 init.ssa=ssa.svd(window(tmp[,paste0("Filtered","ch5")],start=first(index(tmp)),end=first(index(tmp))+60*60),30*10,1,50)
 
## Update graph display, currently commented
#init.nodes=update_nodes_components(init.nodes,init.ssa)
init.ssa_g=grouping.ssa(init.ssa,g=1:(ncol(init.ssa$U)),nc=3)

## Update graph display, currently commented
#init.nodes=update_nodes_cluster(init.nodes,init.ssa_g)
#init.edges=update_edges_cluster(init.nodes,init.edges,init.ssa_g)

## Reconstruction, only for display, currently soft implemented only
init.recons=recons(init.ssa,init.ssa_g,stacked=F)
#}

# init.nodes=update_nodes_recons(init.nodes)
}else{
init.nodes=base.nodes
init.edges=data.frame("from","to")
init.eeg.fits=c()
init.ecg.fits=c()
init.emg.fits=c()
init.eog.fits=c()

}
```

<!-- \begin{tcolorbox}[colback=lhi!30,%gray background -->
<!--                 colframe=lhi!60,% black frame colour -->
<!--                 arc=1mm, auto outer arc,] -->
<!-- MentaLab's Signal Evaluation employes recent signal processing tools, to evaluate ECG and EEG data.     -->
<!-- Furthermore it holds relevant citation and customizable output formats.     -->
<!-- It is extandable by Python and R data analysis methods and curated by professional biostatisticians and medical experts.     -->
<!-- \end{tcolorbox} -->

### Input - data is assumed to be in Voltage and will be converted based on biosource, initial rounding to one microvolt.
<!-- {.sidebar} -->

```{r}

if(shiny_running()){

## Reactive Environement for graph network
graph_data <- reactiveValues(
  nodes = init.nodes,
  edges=init.edges,
  EEG=init.eeg.fits,
  ECG=init.ecg.fits,
  EOG=init.eog.fits,
  EMG=init.emg.fits
)

## Main Reactive Object
if(demoMode==F){
ExG<-reactiveValues(
  ts=as.xts(init.ExG,seq(as.POSIXct("2020-01-31 23:55:00"), by=1/init.srate, length=nrow(init.ExG))),
  srate=init.srate,
  channels=init.channels,
  freq=init.freq_filter,
  bandpower=init.freq.bandpower,
  stages=init.stages,
  orig.chan=init.orig.chan,
  orig.ssa=init.orig.ssa,
  orit.events=init.orig.ssa,
  orig.disp=init.orig.disp,
  disp=init.disp,
  resol=init.resol,
  posix=as.POSIXct("2020-01-31 23:55:00"),
  sight="time",
  newfile=F,
  ssa=init.ssa,
  gssa=init.ssa_g,
  rssa=init.recons,
  events=data.frame(),
  df_res=data.frame(),
  df_res2=data.frame(),
  pan=0,
  hold=1,
  a=0
)
}else{
init.ExG=as.data.frame(rep(0,250*60*60*8))
colnames(init.ExG)="Empty"
init.stages=
init.freq_filter=as.xts(init.ExG,seq(init.Date, by=1/250, length=nrow(init.ExG)))
init.orig.chan=downsample(as.xts(init.ExG,seq(init.Date, by=1/250, length=nrow(init.ExG))),250*60)
init.stages=data.frame(
  "Sleep State (W, S1, S2, S3, REM)"=c("W"),
  "Time (xx:xx or xx:xx:xx)"=init.Date,
                       stringsAsFactors = F)

ExG<-reactiveValues(
  ts=as.xts(init.ExG,seq(init.Date, by=1/250, length=nrow(init.ExG))),
  srate=250,
  channels=c("Empty"),
  freq=init.freq_filter,
  bandpower=data.frame(),
  stages=init.stages,
  orig.chan=init.orig.chan,
  orig.ssa=init.orig.chan,
  orit.events=init.orig.chan,
  orig.disp=init.orig.chan,
  disp=init.orig.chan,
  resol=c(first(init.freq_filter),last(init.freq_filter)),
  posix=init.Date,
  sight="bird",
  newfile=F,
  events=data.frame(),
  df_res=data.frame(),
  df_res2=data.frame(),
  pan=0,
  hold=1,
  a=0
)
  
}
}


if(shiny_running()){
  output$dygraph<-
    renderDygraph({
      if(ExG$newfile){
          d<-dygraph(ExG$disp) %>% dyAxis("y", label = "Electric Potential (V)",valueRange=c(-50,50)) %>%
            dyRangeSelector(height = 90) %>% 
          dyOptions(axisLineWidth = 1.5, drawGrid = FALSE) %>%
            dyLegend(show = "never")
          ExG$newfile=F
      }else{
        ## Seperate Channel by normalizing to IQR and adding a positional vector -"the matrix"
        d<-dygraph(ExG$disp) %>% dyAxis("y", label = "Electric Potential (V)",valueRange=c(-50,50)) %>%
          dyRangeSelector(height = 90,retainDateWindow=T) %>% dyLegend(show = "never") %>% 
          dyOptions(axisLineWidth = 1.5, drawGrid = FALSE) %>% dyCallbacks( 
            annotationClickHandler= 
          "function(ann, point, dg, event){
          ann.div.style.backgroundColor =  '#ddd';
          var message=ann.text;
          Shiny.setInputValue('downRater',message);}")
    }
    if("Bandpower" %in% input$disp_event){
      # Take Bandpower columns - always last ones
      dn<-colnames(ExG$disp)[(ncol(ExG$disp)-5):(ncol(ExG$disp))]
        for(i in dn){
          #display them on other y axis
          d<-d %>% dySeries(i, axis = 'y2',stepPlot = F)
        }
    }
    if("Stages" %in% input$disp_event){
      for(i in 1:(nrow(ExG$stages))){
        if(any(ExG$stages[i,1] %in% c("W","S1","S2","S3","REM","A") )){
          ## Get the closest index value of the displayed time series
          ## Write the annotation there - otherwise does not show an annotation bc timestamp might be missing
            d= d %>% dyAnnotation(index(ExG$disp)[
              which(abs(index(ExG$disp)-ExG$stages[i,2])==min(abs(index(ExG$disp)-ExG$stages[i,2])))],
              text=ExG$stages[i,1],tooltip = as.character(i),width=30,height=30)
          }
      }
    }
    if("Sleep Spindles" %in% input$disp_event){
      for(i in 1:(nrow(ExG$spindles))){
        ## same as above, closest existing timestamp, events are the Sleep Spindles only atm
        d= d %>% dyAnnotation(index(ExG$disp)[
          which(abs(index(ExG$disp)-ExG$spindles[i,2])==min(abs(index(ExG$disp)-ExG$spindles[i,2])))],
          text="Sp",attachAtBottom =T,width=20,height=20)
      }
    }
      if("QRS-Complex" %in% input$disp_event){
      for(i in 1:(nrow(ExG$qrs))){
        ## same as above, closest existing timestamp, events are the Sleep Spindles only atm
        d= d %>% dyAnnotation(index(ExG$disp)[
          which(abs(index(ExG$disp)-ExG$qrs[i,2])==min(abs(index(ExG$disp)-ExG$qrs[i,2])))],
          text="QRS",attachAtBottom =T,width=20,height=20)
      }
    }
    d
  })
}

### FIRST PANEL UI ELEMENTS PLACEMENT
if(shiny_running()){
  fillCol(
    fillRow(
      actionButton("upload","Upload new Data ... "),
        renderUI({
          chansels=colnames(ExG$ts)
          pickerInput(
          inputId = "disp_chan",
          choices =chansels,
          options = list(title = "Channels",
                         `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"),
          multiple = TRUE
          )
        }),
        pickerInput(
          inputId = "disp_event",
          choices = c("Bandpower","Stages","Sleep Spindles","QRS-Complex"),
          options = list(title = "Events",
                         `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"),
          multiple = TRUE
          ),
        renderUI({
          sel_choices=colnames(ExG$rssa)
          pickerInput(
            inputId = "disp_ssa",
            choices = sel_choices,
            options = list(title = "Clusters",
                           `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"),
          multiple = TRUE
          )
        }),
        switchInput(inputId = "sep_chan",
                    label = "parallel lines", value=F,size="large"),flex=c(1,2,2,2,1)),
    ### INPUTS FINISHED -> NEXT COLUMN: GRPAHIC
    dygraphOutput("dygraph")
    ,flex = c(1,10))
}else{
  ## STATIC DISPLAY HYPNOGRAM
  # it's W, REM, S1, S2, S3,
  # d=data.frame(x=c(1,2,4,5,7,8,9), y=c(1,2,3,5,6,7,9))
  d=EXG$stages
  d[,1]=factor(d[,1],levels = c("S3","S2","S1","REM","W","A"))
  colnames(d)=c("y","x")
ggplot() +
geom_step(data=d, mapping=aes(x=x, y=y),group=1)+theme_classic()
}

```


```{r,file_observer}

# ## Input controls first page, used when uploaded only
# if(shiny_running()){
#   dateInput("rec_date", label="Start Date", value = NULL, min = NULL, max = NULL,
#   format = "yyyy-mm-dd", startview = "month", weekstart = 0,
#   language = "en", width = NULL, autoclose = TRUE,
#   datesdisabled = NULL, daysofweekdisabled = NULL)
# }
# 
# if(shiny_running()){
#   textInput("rec_time", "Start Time (xx:xx or xx:xx:xx)", value = init.time, width = NULL,
#   placeholder = NULL)
# }
# 
# if(shiny_running()){
# sliderInput("srate", label = "Sampling Frequency", min = 0,max = 400, value = 250,step=10)
# }
#   
# if(shiny_running()){
#   fileInput("static_data", "Upload Data (EDF/CSV/BIN):", multiple = F, accept = c(".csv",".edf",".BIN"),
#       width = NULL, buttonLabel = "Browse...",
#       placeholder = "No file selected")
# }

## initial extra modal for difficult parameter entry only
# if(shiny_running()){
# observeEvent(input$upload,{
#   showModal(modalDialog(
#   
#   
#   ,
#   
#   )
# })

## Include Export and Import Options, funcitons is faulty
## DATA upload actions, currently only EDF and csv
if(shiny_running()){
observeEvent(input$static_data,{
      if(any(grepl(".edf",input$static_data))){
        tmp=import_raw(input$static_data$datapath)
        # tmp=import_raw(paste0(mainDir,"/Data/slp03.edf"))
        ExG$srate=tmp[["srate"]]
        tmp=tmp[["signals"]]
        ExG$posix=as.POSIXct(paste(input$rec_date,input$rec_time))
        ExG$ts=as.xts(data.frame(tmp),
                      seq(ExG$posix, 
                          by=1/ExG$srate, length=nrow(data.frame(tmp))))

      }
      if(any(grepl(".csv",input$static_data))){
        tmp=fread(input$static_data$datapath)
        ExG$srate=as.numeric(input$srate)
        ExG$posix=as.POSIXct(paste(input$rec_date,input$rec_time))
        ExG$ts=as.xts(data.frame(tmp),
                      seq(ExG$posix, 
                          by=1/ExG$srate, length=nrow(data.frame(tmp))))
        
      }
      if(any(grepl(".BIN",input$static_data))){
        #ExG$a=1
        #file.copy(input$static_data$datapath,paste0(mainDir,"Data/"))
        py$import_explorepy(input$static_data$datapath)
        ExG$a=2
        # file.copy(input$static_data$datapath,paste0(mainDir,"Data/"))
        tmp=fread(paste0(mainDir,"/0_exg.csv"))
        ExG$a=3
        ExG$srate=as.numeric(input$srate)
        ExG$posix=as.POSIXct(paste(input$rec_date,input$rec_time))
        ExG$ts=as.xts(data.frame(tmp),
                       seq(ExG$posix, 
                           by=1/ExG$srate, length=nrow(data.frame(tmp))))
        
      }
      # get column names
      graph_data$nodes=update_nodes(base.nodes,tmp)
      biosigs=subset(graph_data$nodes,group=="biological")
      physigs=subset(graph_data$nodes,group=="physical")
      digsigs=subset(graph_data$nodes,group=="digital")
      #

      graph_data$edges=setNames(data.frame(matrix(ncol = 3, nrow = 0)), c("from", "to","id"))
      ExG$freq=ExG$ts
      colnames(ExG$freq)=paste0("Filtered",colnames(ExG$ts))
      ExG$orig.chan=downsample(ExG$freq,60*15)
      ExG$orig.ssa=downsample(ExG$freq,60*15)
      ExG$orig.disp=downsample(ExG$freq,60*15)
      ExG$disp=downsample(ExG$freq,60*15)
      ExG$newfile=T
      #
      # ExG$orig.disp=tmp
      # ## reset UI elements below
      # ExG$sight="bird"
       a=first(index(ExG$orig.disp))
       b=last(index(ExG$orig.disp))
      # tmp=downsample(window(ExG$orig.disp,start=a,end=b),250*60)
       ExG$resol=c(a,b)
      # ExG$disp=tmp
      # ExG$newfile=T
    ExG$stages=data.frame("Sleep State (A, W, S1, S2, S3, REM)"="W",
                        "Time (xx:xx or xx:xx:xx)"=first(seq(ExG$posix,by=1/ExG$srate,length=nrow(ExG$ts))),
                        stringsAsFactors = F)
    graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1)
      graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2)
      graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3)
      graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4)
  })

observeEvent(input$srate,{
  ExG$srate=input$srate
})
}

if(shiny_running()){
observeEvent(input$upload,{
  showModal(modalDialog(
  fillRow(dateInput("rec_date", label="Start Date", value = NULL, min = NULL, max = NULL,
  format = "yyyy-mm-dd", startview = "month", weekstart = 0,
  language = "en", width = NULL, autoclose = TRUE,
  datesdisabled = NULL, daysofweekdisabled = NULL),
  textInput("rec_time", "Start Time (xx:xx or xx:xx:xx)", value = init.time, width = NULL),
  placeholder = NULL),
  fillRow(numericInput("srate","Sampling Frequency",value=250,min=1,max=1000),
  fileInput("static_data", "Upload Data (EDF/CSV/BIN):", multiple = F, accept = c(".csv",".edf",".BIN"),
      width = NULL, buttonLabel = "Browse...",
      placeholder = "No file selected")),
  renderTable(head(ExG$ts)),size="l"
  )
)
})
}

```


### Source & Filter - add edges from channels to biosources, select biosources and apply filter settings


```{r}
# tag$script('$(document).on("keypress",function(e) {
#               Shiny.onInputChange("keyinput",e.which);
#              })')
```


```{r,visnetwork}

if(shiny_running()){
  ## Graph Network - fontawesome not working, some manipulations should be disaabled, clusters not displayed
  output$visnet<-renderVisNetwork({
    visNetwork(graph_data$nodes,graph_data$edges) %>%
      visOptions(nodesIdSelection = list(enabled=T,values = c(1:4)),manipulation = list(
    enabled= T,
    initiallyActive= T,
    addNode= F,
    addEdge= T,
    editEdge= F,
    deleteNode= F,
    deleteEdge= T
    )) %>%visInteraction(multiselect=T,
                         dragNodes = T,
                         dragView = T,
                         zoomView = T) %>%
      visGroups(groupname = "digital", shape = "icon",
            icon = list(code = "f31b", size = 75,face = 'Ionicons',color="black")) %>%
      visGroups(groupname = "physical", shape = "icon",
                icon = list(code = "f3a7", size=75,face = 'Ionicons',color="red"))%>%
      visGroups(groupname = "biological", shape = "icon",
                icon = list(code = c('f493'), size=75,color="green",face = 'Ionicons'))  %>%
      visGroups(groupname = "Component", shape = "icon",                
                icon = list(code = "f2e9", size = 25,color="orange",face = 'Ionicons')) %>%
      visGroups(groupname = "Cluster", shape = "icon",
                    icon= list(code = "f25c", size = 75,color="blue",face= 'Ionicons')) %>% addIonicons()%>% visEdges(arrows = "to") %>% 
  visHierarchicalLayout( levelSeparation = 200,nodeSpacing=50,treeSpacing=100)

  })

  visNetworkOutput("visnet")
}

# visEvents(select = "function(nodes) {
#                 Shiny.onInputChange('current_node_id', nodes.nodes);
#                 ;}") %>%
# %>%
#                  visEvents(select = "function(nodes) {
#                 Shiny.onInputChange('current_node_id', nodes.nodes);
#                 ;}")

  # observeEvent(input$current_node_id, {
  #   visNetworkProxy("visnet") %>%
  #     visGetNodes()
  # })

if(shiny_running()){
## Watch Manipulation of network - also implement renaming columns
## Some features are implemented but disabled by the graph network
## No real ?eval expressions just some features (hard) evaluated
  observeEvent(input[["visnet_graphChange"]],{
    # If the user added a node, add it to the data frame of nodes.
    if(input[["visnet_graphChange"]][["cmd"]] == "addNode") {
      temp = bind_rows(
        graph_data$nodes,
        data.frame(id = input[["visnet_graphChange"]]$id,
                   label = input[["visnet_graphChange"]]$label,
                   stringsAsFactors = F)
      )
      graph_data$nodes = temp
    }
    # If the user added an edge, add it to the data frame of edges.
    else if(input[["visnet_graphChange"]]$cmd == "addEdge") {
      tmp = bind_rows(
        graph_data$edges,
        data.frame(id=(nrow(graph_data$edges)+1) ,
                   from =input[["visnet_graphChange"]]$from,
                   to = input[["visnet_graphChange"]]$to,
                   stringsAsFactors = F)
      )
      ## if eeg changed
      if(length(findexg(graph_data$nodes,graph_data$edges,1))!=
         length(findexg(graph_data$nodes,tmp,1))){
        ## to and from cases
        if(as.character(input[["visnet_graphChange"]]$to) %in%
           as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$to )])
            ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*(1000*1000)
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000*1000)
          }else{
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$from )])
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*(1000*1000)
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000*1000)
             }
      }
      if(length(findexg(graph_data$nodes,graph_data$edges,2))!=
         length(findexg(graph_data$nodes,tmp,2))|
         length(findexg(graph_data$nodes,graph_data$edges,3))!=
         length(findexg(graph_data$nodes,tmp,3))|
         length(findexg(graph_data$nodes,graph_data$edges,4))!=
         length(findexg(graph_data$nodes,tmp,4))){
          if(as.character(input[["visnet_graphChange"]]$to) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$to) ])
            ## convert all data to uV range - now only timeseries, but also filters, disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*1000
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*1000
          }else{
            chan=as.character(subset(graph_data$nodes,group=="physical")$label[
              as.character(subset(graph_data$nodes,group=="physical")$id) %in%
              as.character(input[["visnet_graphChange"]]$from )])
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]*(1000)
            ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000)
             }
         }

      graph_data$edges = tmp
    }
    # If the user edited a node, update that record.
    else if(input[["visnet_graphChange"]]$cmd == "editNode") {
      temp = graph_data$nodes
      temp$label[as.character(temp$id) == as.character(input[["visnet_graphChange"]]$id)] = as.character(input[["visnet_graphChange"]]$label)
      graph_data$nodes = temp
      physigs=as.character(subset(graph_data$nodes,group=="physical")$label)
      colnames(ExG$ts)=physigs
      colnames(ExG$freq)=paste0("Filtered",physigs)

    }
    # If the user edited an edge, update that record.
    else if(input[["visnet_graphChange"]]$cmd == "editEdge") {
      temp = graph_data$edges
      temp$from[temp$id == input[["visnet_graphChange"]]$id] = input[["visnet_graphChange"]]$from
      temp$to[temp$id == input[["visnet_graphChange"]]$id] = input[["visnet_graphChange"]]$to
      graph_data$edges = temp
    }
    # If the user deleted something, remove those records.
    if(input[["visnet_graphChange"]]$cmd == "deleteElements") {
      globtmp=graph_data$nodes
      for(node.id in input[["visnet_graphChange"]]$nodes) {
        tmp = globtmp
        tmp = tmp[tmp$id != node.id,]
        globtmp = tmp
      }
      graph_data$nodes=globtmp
      globtmp=graph_data$edges
      for(edge.id in input[["visnet_graphChange"]]$edges) {
        tmp = globtmp
        tmp = tmp[tmp$id != edge.id,]

        globtmp = tmp
      }
      tmp=globtmp
      if(length(findexg(graph_data$nodes,graph_data$edges,1))!=
         length(findexg(graph_data$nodes,tmp,1))){
      for(i in input[["visnet_graphChange"]]$edges){
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"])]
            ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000*1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            ## convert all data to uV range - now only timeseries, but also filters, disp, etc.
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"])]
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000*1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
      }
      }
      if(length(findexg(graph_data$nodes,graph_data$edges,2))!=
         length(findexg(graph_data$nodes,tmp,2))|
         length(findexg(graph_data$nodes,graph_data$edges,3))!=
         length(findexg(graph_data$nodes,tmp,3))|
         length(findexg(graph_data$nodes,graph_data$edges,4))!=
         length(findexg(graph_data$nodes,tmp,4))){
        for(i in input[["visnet_graphChange"]]$edges){
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"])]
            ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
          if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"]) %in%
             as.character(subset(graph_data$nodes,group=="physical")$id)){
            ## convert all data to uV range - now only timeseries, but also filters, disp, etc.
            chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"])]
            ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc.
            ExG$ts[,chan]=ExG$ts[,chan]/(1000)
            # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan]
          }
        }
      }
      graph_data$edges=tmp
    }
      graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1)
      graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2)
      graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3)
      graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4)
})
}

# renderPrint(print(visGetSelectedNodes("")))
  # observeEvent(input$current_node_id, {
  #   visNetworkProxy("network_proxy") %>%
  #     visGetNodes()
  # })

# observeEvent(input$visnet_selected,{
#   if(any(input$visnet_selected %in% graph_data$nodes[graph_data$nodes$group %in% "Cluster","id"])){
#
#     selicks=subset(graph_data$nodes,group=="Cluster")[graph_data$nodes[graph_data$nodes$group %in% "Cluster","id"] %in% input$visnet_selected,]
#
#     update_nodes_components()
#
#   }
#
# })


```


```{r,filter_apply}

if(shiny_running()){
observeEvent(input$filter_button,
             {
    if(!is.null(input$visnet_selected)&any(input$visnet_selected %in% biosigs$id)){
      vis_sub=input$visnet_selected[input$visnet_selected %in% biosigs$id]

      chans=graph_data$nodes$id %in% input$visnet_selected

      filt_ch=as.character(graph_data$nodes[chans,"label"])

      # if notch filtered, create new edge signal to filter
      if(input$stoppoint!=0){
        graph_data$edges=bind_rows(graph_data$edges,
          data.frame(label=(nrow(graph_data$edges)+1):
                           (nrow(graph_data$edges)+
                              length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])),
                 from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch],
                 to=graph_data$nodes$id[graph_data$nodes$label %in% "Notch"],
          title=paste0("<p>Notch:", input$stoppoint,"</p>"),
          value=1,stringsAsFactors = F))
      }
      ## same for passband
      if(any(input$passband!=c(0,250))){
        graph_data$edges=bind_rows(graph_data$edges,
          data.frame(label=(nrow(graph_data$edges)+1):
                           (nrow(graph_data$edges)+
                              length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])),
                 from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch],
                 to=graph_data$nodes$id[graph_data$nodes$label %in% "Low Pass"],
          title=paste0("<p>Low Pass:", input$passband[1],"</p>"),
          value=(input$passband[2]-input$passband[1])/(ExG$srate/2),stringsAsFactors = F))
        graph_data$edges=bind_rows(graph_data$edges,
          data.frame(label=(nrow(graph_data$edges)+1):
                           (nrow(graph_data$edges)+
                              length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])),
                 from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch],
                 to=graph_data$nodes$id[graph_data$nodes$label %in% "High Pass"],
          title=paste0("<p>High Pass:", input$passband[2],"</p>"),
          value=(input$passband[2]-input$passband[1])/(ExG$srate/2),stringsAsFactors = F))
      }
      ## apply filter

      tmp=freq_filter(ExG$ts[,graph_data[[filt_ch]]],ExG$srate,
                      as.numeric(as.character(input$stoppoint)),
                      input$passband,graph_data[[filt_ch]])

      colnames(tmp)<-paste0("Filtered",colnames(tmp))
      ExG$freq[,(colnames(ExG$freq) %in% paste0("Filtered",graph_data[[filt_ch]]))]=tmp


      # tmp2=ExG$freq[,!(colnames(ExG$freq) %in% paste0("Filtered",graph_data[filt_ch]))]
      # ExG$freq<-as.xts(tmp[,(colnames(tmp) %in% paste0("Filtered",graph_data[filt_ch]))],
      #              seq(ExG$posix, by=1/ExG$srate,length=nrow(tmp)))
      # ExG$freq=cbind(ExG$freq,tmp2)
      # ExG$freq[,order()]

      ## Change width of edge
      # graph_data$edges
    }
   
})
}
```

***

```{r, filter_ui}
if(shiny_running()){
  selectInput("stoppoint", label = "Select (Notch) Frequency to silence:",
              choices = c(0, 50, 60), selected = 0)
}

if(shiny_running()){
  renderUI({sliderTextInput(
   inputId = "passband",
   label = "Select Band to pass:",
    choices = c(seq(0.1,10,by=0.1),seq(10,round(ExG$srate/2,0))),
selected = c(2, 30),
   from_min = 0.1,
    from_max = 10,
   to_min = 30,
   to_max = 100,
   grid = TRUE
)})
}

# renderPrint( {
#     if (!is.null(input$current_node_id) && !is.null(input$visnet_nodes)) {
#       print(input$current_node_id)
#       # info <- data.frame(matrix(unlist(),
#       #                           ncol = dim(nodes)[1], byrow = T),
#       #                    stringsAsFactors = FALSE)
#       # colnames(info) <- colnames(nodes)
#       # info[info$id == input$current_node_id, ]
#     }
#   })


# renderPrint(print(visNetworkProxy("visnet")%>%visGetSelectedNodes()))
#
# if(shiny_running()){
#   renderUI({
#   spindle_choices=c(colnames(ExG$freq),paste0("Clust",names(ExG$gssa)))
#
#   pickerInput(
#     inputId = "",
#     label = "Select Channels/Sources for Spindle Detection",
#     choices =spindle_choices,
#     options = list(
#     `actions-box` = TRUE,
#     size = 10
#   ),
#   multiple = F
#   )
#   })
# }



if(shiny_running()){
  actionButton("filter_button", "Apply Filter / Bandpower")
}



```

```{r}

# renderPrint(print(c(filter_value(graph_data$nodes,graph_data$edges,s="EEG"),filter_value(graph_data$nodes,graph_data$edges,s="ECG"),filter_value(graph_data$nodes,graph_data$edges,s="EOG"),filter_value(graph_data$nodes,graph_data$edges,s="EMG"))))
if(shiny_running()){
  textInput("pat_desc", "Patient Description",
              value = "John Doe, M, 25, Apnoe, no Medication", placeholder = "Name of Patient")
}

if(shiny_running()){
  downloadButtonRmd("downloadEDF", "Download EDF")
}

# observeEvent(input$edf_create,{
#   showModal(modalDialog(
#   ,
#
#       )
#     )
# })

```


```{r,edfoutput,echo=F}

if(shiny_running() ){
output$downloadEDF <- downloadHandler(
  filename = function(){paste0(input$pat_desc,"_",format(as.Date(ExG$posix),format="%d.%m.%y"),".edf")},
  content = function(file){
    edf_dat=ExG$freq[,paste0("Filtered",c(graph_data$EEG,graph_data$ECG,graph_data$EOG,graph_data$EMG))]
    # edf_dat[,paste0("Filtered",graph_data$EEG)]=round(edf_dat[,paste0("Filtered",graph_data$EEG)],0)
    # edf_dat[,paste0("Filtered",c(graph_data$ECG,graph_data$EOG,graph_data$EMG))]=
    #   round(edf_dat[,paste0("Filtered",c(graph_data$ECG,graph_data$EOG,graph_data$EMG))]/1000,3)
    unitz=c(rep("uV",length(graph_data$EEG)),rep("mV",length(c(graph_data$ECG,graph_data$EOG,graph_data$EMG))))
    ##Transform unit according to Signal
    # scaleExGsig<-function(df,eegs,ecgs,eogs,emgs){
    #   df[,paste0("Filtered",eegs)]<-df[,paste0("Filtered",eegs)]*1000000
    #   df[,paste0("Filtered",c(ecgs,eogs,emgs))]<-df[,paste0("Filtered",c(ecgs,eogs,emgs))]*1000
    #   return(df)
    # }
    # edf_dat=scaleExGsig(edf_dat,graph_data$EEG,graph_data$ECG,graph_data$EOG,graph_data$EMG)

    ## Could be better from source relation naming
    snames=c(paste0("EEG",graph_data$EEG),
             paste0("ECG",graph_data$ECG),
             paste0("EOG",graph_data$EOG),
             paste0("EMG",graph_data$EMG))

    # prefilterings=c(rep(paste0("N:",input$stoppoint,"Hz L:",input$passband[1],"Hz H:",input$passband[2],"Hz"),
    #                     length(graph_data$EEG)),
    #                 rep(paste0("N:",0,"Hz L:",0,"Hz H:",2*ExG$srate,"Hz"),
    #                     length(c(graph_data$ECG,graph_data$EOG,graph_data$EMG))))
    
    prefilterings=c(filter_value(graph_data$nodes,graph_data$edges,s="EEG"),filter_value(graph_data$nodes,graph_data$edges,s="ECG"),filter_value(graph_data$nodes,graph_data$edges,s="EOG"),filter_value(graph_data$nodes,graph_data$edges,s="EMG"))
    srs=rep(ExG$srate,ncol(edf_dat))

    recId="None"
    patId=input$pat_desc
    startdate=format(as.Date(ExG$posix),format="%d.%m.%y")
    starttime=strftime(ExG$posix,format = "%H.%M.%S")
    fn=paste0(mainDir,"/",input$pat_desc,"_",startdate,".edf")
signals=edf_dat

  if(file.exists(fn)) {file.create(fn,overwrite=T)
    }else{file.create(fn,overwrite=F)}
  fid<-file(fn,'wb')
  numSignals <- length(srs)

  ## Mentalab Rounding
  # signals=round(signals,2)

  # Calculate recording length (in seconds)
  recLength <- (-1)
  for (k in 1:numSignals){
    recLength <- max(recLength, length(signals[,k])/srs[k])
  }
  recLength <- ceiling(recLength)# Ceil to an integer number

  # Asuming 1s databloack duration. Check possible incompatibilities
  blockSizeBytes <- sum(2*srs)

  if(blockSizeBytes > 61440){
    print('Yet to be implemented: Signals cannot fit on a 1s datablock. Check for (other block size possibilities)')
  } else {
    blockSize <- 1
    numBlocks <- recLength
  }

  general_header_size <- 256#bytes
  one_signal_header_size <- 256#bytes

  # Write edf

  # FIXED HEADER
  header.version <- 0
  header.local_patient_identification <- patId
  header.local_recording_identification <- recId
  header.startdate_recording <- startdate
  header.starttime_recording <- starttime
  header.num_signals <- numSignals
  header.num_bytes_header <- general_header_size + one_signal_header_size * numSignals
  header.reserved <- ''
  header.duration_data_record <- blockSize
  header.num_data_records <- numBlocks

  trimAndFillWithBlanks<-function(txt, maxLength, justify='left'){
    # if(nargin == 2)justify = 'left'
    if(nchar(txt) > maxLength){result = substr(txt,1,maxLength)
    }else{
      if(justify== 'right'){
        result<-paste0(paste0(rep(" ",(maxLength-length(txt))),collapse=""),txt)}
      else{
        result<-paste0(txt,paste0(rep(" ",(maxLength-nchar(txt))),collapse=""))
      }
    }
    return(result)
  }

  writeBin(charToRaw(trimAndFillWithBlanks(header.version,8)),fid,endian = "little")# version
  writeBin(charToRaw(trimAndFillWithBlanks(header.local_patient_identification,80)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.local_recording_identification,80)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.startdate_recording,8)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.starttime_recording,8)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.num_bytes_header,8)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.reserved,44)),fid,endian="little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.num_data_records,8)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.duration_data_record,8)),fid,endian = "little")
  writeBin(charToRaw(trimAndFillWithBlanks(header.num_signals,4)),fid,endian = "little")

  # SIGNAL DEPENDENT HEADER
  signalOffsets <- rep(0, numSignals)# In bytes
  header.signals_info=data.frame(label=rep("",numSignals),
                                 transducer_type=rep("",numSignals),
                                 physical_dimension=rep("",numSignals),
                                 physical_min=rep("",numSignals),
                                 physical_max=rep("",numSignals),
                                 digital_min=rep("",numSignals),
                                 digital_max=rep("",numSignals),
                                 prefiltering=rep("",numSignals),
                                 num_samples_datarecord=rep("",numSignals),
                                 reserved=rep("",numSignals),
                                 sample_rate=rep("",numSignals),
                                 signalOffset=rep("",numSignals),stringsAsFactors = F)

  # for(i in 1:ncol(header.signals_info)){
  #   header.signals_info[colnames(header.signals_info)[i]]<-as.character(header.signals_info[colnames(header.signals_info)[i]])
  # }

  #Mentalab values
  Pmins<-floor(unlist(lapply(signals,min)))
  # Pmins<-floor(unlist(lapply(signals,max))[seq(2, ncol(signals)*5, 5)])
  Pmaxs<-ceiling(unlist(lapply(signals,max)))
  # Pmaxs<-ceiling(unlist(lapply(signals,quantile))[seq(4, ncol(signals)*5, 5)])
  Dmins<-rep(-32768,numSignals)
  Dmaxs<-rep(32767,numSignals)

  if( (  log(    (max(abs(Dmins))+max(abs(Dmaxs))+1) ,2  ) / (max(abs(Pmins))+max(abs(Pmaxs)))    )  > 16 ){ print("Error, Accucracy to high, not 16 bit, either shrink distance !Dmin to Dmax!, or Pmin to Pmax")}

  for (k in 1:numSignals){
    header.signals_info[k,"label"] <- snames[k]
    header.signals_info[k,"transducer_type"] <- ''
    header.signals_info[k,"physical_dimension"] <- unitz[k]

    header.signals_info[k,"physical_min"] <- Pmins[k]
    header.signals_info[k,"physical_max"] <- Pmaxs[k]
    header.signals_info[k,"digital_min"] <- Dmins[k]
    header.signals_info[k,"digital_max"] <- Dmaxs[k]

    header.signals_info[k,"prefiltering"] <- prefilterings[k]
    header.signals_info[k,"num_samples_datarecord"] <- as.character(as.numeric(srs[k])*as.numeric(blockSize))
    header.signals_info[k,"reserved"] <- ''
    # NOTE: The two following are not specific EDF header fields, but are practical for EDF handling
    header.signals_info[k,"sample_rate"] <- as.character(as.numeric(header.signals_info[k,"num_samples_datarecord"])/
      as.numeric(header.duration_data_record))
    if (k > 1){
      signalOffsets[k] <- signalOffsets[k - 1] + 2 * as.numeric(header.signals_info[k - 1,"num_samples_datarecord"])
    }
    header.signals_info[k,"signalOffset"] <- signalOffsets[k]
  }

  # Write signal-dependent header to file
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"label"],16)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"transducer_type"],80)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"physical_dimension"],8)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"physical_min"]),8)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"physical_max"]),8)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"digital_min"]),8)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"digital_max"]),8)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"prefiltering"],80)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"num_samples_datarecord"]),8)),fid,endian="little")
  }
  for (k in 1:numSignals){
    writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"reserved"],32)),fid,endian="little")
  }

  # Check data starting point
  current_position <-seek(fid)# in bytes
  if (header.num_bytes_header!= current_position){
    print('Something wrong could be happening: unexpected position at the beginning of the first data block')
  }
  bytes_full_data_record <- 2 * sum(as.numeric(unlist(header.signals_info["num_samples_datarecord"])))

  # DATA WRITING


  close(fid)

  for (k in 1:numBlocks){
    printmes=F
    if((k %% 100)==0 & printmes==T)ExG$a=k
    # Initialize datablock
    data <- rep(0, bytes_full_data_record/2)# Num samples per data record

    for (k1 in 1:numSignals){
      offsetSignal <- (k - 1) * as.numeric(header.signals_info[k1,"num_samples_datarecord"]) + 1
      onsetSignal <- min(offsetSignal + as.numeric(header.signals_info[k1,"num_samples_datarecord"]) - 1,
                         length(signals[,k1]))
      offsetDataBlock <- as.numeric(header.signals_info[k1,"signalOffset"])/2 + 1
      onsetDataBlock <- offsetDataBlock +  onsetSignal-offsetSignal
      data[offsetDataBlock:onsetDataBlock] <- as.integer(Dmins[k1] + (Dmaxs[k1] - Dmins[k1]) *
                                                           ((signals[offsetSignal:onsetSignal,k1] - Pmins[k1])/(Pmaxs[k1] - Pmins[k1])))
    }
    if(max(int_to_unit(data))>65536)print("Error")
    py$writeEDFbin(fn,data)
  }


    file.rename(fn, file)
  }
)
}



```



### Sleep Spindles and QRS Detection

```{r}
if(shiny_running()){
  observeEvent(input$ana_button,{
    if(!is.null(input$ecg_ana)){
    res=py$qrs_detect(coredata(ExG$ts)[,input$ecg_ana],ExG$srate)
    ExG$qrs=data.frame(rep("QRS",length(res)),first(index(ExG$ts))+res)
    ExG$hrv=hrv_analysis(res,ExG$srate,mainDir)
    }
  })
}

hrv_analysis<-function(rr,srate,mainDir){
  library(RHRV)
    #create correct data frame and turn on text info mode
    write.table(rr/srate,paste0(mainDir,"/Data/rr.txt"),row.names = F, col.names = F,sep=",",dec=".")
    hrv_df<-CreateHRVData()
    hrv_df<-SetVerbose(hrv_df,Verbose=F)

    #load data
    hrv_df = LoadBeatAscii(hrv_df, "rr.txt",RecordPath = paste0(mainDir,"/Data/"))

    # calculate non-interpolated RR intervals
    hrv_df = BuildNIHR(hrv_df)

    #filter unacceptable data points
    hrv_df=FilterNIHR(hrv_df)

    #interpolation neccessary for spectral analysis
    hrv_df.freq = InterpolateNIHR (hrv_df, freqhr = 1)
    hrv_df.freq = CreateFreqAnalysis(hrv_df.freq)

    #Calculate and Plot Powerbands7make transparent
    hrv_df.freq = CalculatePowerBand(hrv_df.freq, indexFreqAnalysis= 1,shift=2,size=30,
                                                     type = "fourier",
                                                     bandtolerance = 0.01, relative = FALSE)


    #Create and Print Time Analysis
    hrv_df.time = CreateTimeAnalysis(hrv_df, size = 300,interval = 7.8125)


    # Nonlinear Analysis and Poincare Plot
    hrv_df.nonlin = CreateNonLinearAnalysis(hrv_df)

     return(list(hrv_df.freq,hrv_df.time,hrv_df.nonlin))
  }

if(shiny_running()){
fillCol(renderTable({res=as.data.frame(ExG$hrv[[2]]["TimeAnalysis"])
colnames(res)=unlist(lapply(strsplit(colnames(res),"TimeAnalysis."),function(x)x[[2]]))
round(res,0)}),
fillRow(
renderPlot({PlotSinglePowerBand(ExG$hrv[[1]], 1, "LF/HF",doPlot=T,main="heart related stress adaption",                     eplim=c(min(ExG$hrv[[1]]$FreqAnalysis[[1]]$LFHF),max(ExG$hrv[[1]]$FreqAnalysis[[1]]$LFHF)))}),

renderPlot({PoincarePlot(ExG$hrv[[3]],indexNonLinearAnalysis=1,timeLag=1, doPlot=T)})),flex=c(1,5))
}else{
  kable(as.data.frame(EXG$hrv[[2]]["TimeAnalysis"]))
  
  PlotSinglePowerBand(EXG$hrv[[1]], 1, "LF/HF",doPlot=T,main="heart related stress adaption",                     eplim=c(min(EXG$hrv[[1]]$FreqAnalysis[[1]]$LFHF),max(EXG$hrv[[1]]$FreqAnalysis[[1]]$LFHF)))
  PoincarePlot(EXG$hrv[[3]],indexNonLinearAnalysis=1,timeLag=1, doPlot=T)
  
        
  
}
```


***


```{r}

if(shiny_running()){
  sliderInput("L", label = "Window Length", min = 10,max = 50, value = 30,step=1)
}


if(shiny_running()){
  # dropdown(
  # tags$h3("List of Input"),
  renderUI({
  eeg_choicings=c(graph_data$EEG)

  pickerInput(
    inputId = "eeg_ana",
    label = "Select Channel for Sleep Spindles & Baandpower",
    choices =c(eeg_choicings),
    options = list(
    `actions-box` = TRUE,
    size = 10
  ),
  multiple = F
  )
  })
}


if(shiny_running()){
  # dropdown(
  # tags$h3("List of Input"),
  renderUI({
    ecg_choicings=c(graph_data$ECG)

  pickerInput(
    inputId = "ecg_ana",
    label = "Select Channel for QRS Detection",
    choices =ecg_choicings,
    options = list(
    `actions-box` = TRUE,
    size = 10
  ),
  multiple = F
  )
  })
}
if(shiny_running()){
  actionButton("ana_button", label = "Analyze")
}

```




### Singular Spectrum Analysis - Manual Clustering: Click on Component (red square) -> Click on Component in New Cluster


```{r, staging table and SSA plot}
if(shiny_running()){
  output$stages<-renderDT({
    DT::datatable(
      data.frame(
        cbind(
          ExG$stages[,1],
          strftime(ExG$stages[,2],format="%H:%M:%S")),
        stringsAsFactors = F),
      editable=F,options = list(dom = 't'),
      colnames = c("Stage","Time"))
    })
}
```

```{r}
### OBSERVER FOR EDITING
# if(shiny_running()){
#   #Editable stages
#   observeEvent(input[["stages_cell_edit"]],{
#     tmp=input[["stages_cell_edit"]]
#     if(tmp$col==2){
#       if(length(strsplit(tmp$value,":")[[1]])>=2){
#         if(!to_day(ExG$posix,tmp$value)){
#           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,tmp$value))
#         }else{
#           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),tmp$value))
#         }
#       }
#       if(length(strsplit(tmp$value,":")[[1]])==2){
#         if(!to_day(ExG$posix,tmp$value)){
#           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,paste0(tmp$value,":00")))
#         }else{
#           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),paste0(tmp$value,":00")))
#         }
#       }
#     }
#     else{
#     ExG$stages[tmp$row,tmp$col]<-tmp$value
#     }
#     ExG$stages=ExG$stages[!(ExG$stages[,1] %in% c("")),]
#   })
# }
```


```{r}
if(shiny_running()){
output$telco<-renderPlot({
if(!is.null(input$ssa_channel) & ExG$hold==0){
  ###################GRAPHIC FOR ONE STAGE WITH ALL COMPONENTS
#   if(length(input$stages_rows_selected)!=1){
#     if(input$time_real==F){
#   p= ggplot()+geom_line(data=ExG$df_res,aes(x=ind,y=Value))+
#     geom_line(data=ExG$df_res,aes(x=ind,y=Value,group=Comp,color=Comp))+
#     theme_classic()+facet_grid(rows = vars(Row),cols=vars(Column))+theme(legend.position = "none")+
#     scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
#   }else{
#   p= ggplot()+geom_line(data=ExG$df_res2,aes(x=ind,y=Value))+
#     geom_line(data=ExG$df_res2,aes(x=ind,y=Value,group=Real,color=Real))+
#     theme_classic()+facet_grid(rows = vars(Row),cols=vars(Column))+theme(legend.position = "none")+
#     scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
# 
#     }
#   p
# }else{
#####################GRAPHIC FOR MANY STAGE FOR EACH CLUSTER
  
  if(input$time_real==F){
 # p=ggplot()+geom_line(
 #        data=ExG$df_res[ExG$df_res$Column==input$stages_rows_selected,],
 #        aes(x=ind,y=Value,group=Comp,color=Comp))+
 #        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+
 #   geom_rect(data = ExG$df_res[ExG$df_res$Column==input$stages_rows_selected & ExG$df_res$Comp %in% ExG$pan[2],], 
 #                          fill = NA, colour = "red", xmin = -Inf,xmax = Inf,
 #            ymin = -Inf,ymax = Inf)+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
 #      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
 
 p=ggplot()+geom_line(
        data=ExG$df_res,
        aes(x=ind,y=Value,group=Comp,color=Comp))+
        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+
   geom_rect(data = ExG$df_res[ExG$df_res$Comp %in% ExG$pan[2],], 
                          fill = NA, colour = "red", xmin = -Inf,xmax = Inf,
            ymin = -Inf,ymax = Inf)+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
      
    }else{
 # p=ggplot()+geom_line(
 #        data=ExG$df_res2[ExG$df_res2$Column==input$stages_rows_selected,],
 #        aes(x=ind,y=Value,group=Real,color=Real))+
 #        theme_classic()+facet_wrap(c(vars(Real),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
 #      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
 p=ggplot()+geom_line(
        data=ExG$df_res2,
        aes(x=ind,y=Value,group=Real,color=Real))+
        theme_classic()+facet_wrap(c(vars(Real),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
      
    }
    p
# }
}
})

}else{
  
  ggplot()+geom_line(
        data=EXG$df_res,
        aes(x=ind,y=Value,group=Comp,color=Comp))+
        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+
      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index")
}

if(shiny_running()){
    fillRow(
    #################STAGING TABLE FOR SELECTION
    fillCol(
      renderUI({
        ssas=graph_data$EEG
        pickerInput(
          inputId = "ssa_channel",
          choices =ssas,
          options = list(title = "Channels",`actions-box` = TRUE,size = 10),
          multiple = T
        )
      }),
      # DTOutput("stages"),flex=c(1,5)),
    # fillCol(
       switchInput(inputId = "time_real", label = "timed Realization", value=F),
      # renderUI({
      # if(!is.null(input$stages_rows_selected)){
      # if(input$stages_rows_selected==1){
      # ############################### UI ELEMENTS FOR SSA TO EACH STAGE OR
      knobInput(
        inputId = "neigs",
        label = "Number of Components",
        value = 20,
        max = 50,
        min=2,
        displayPrevious = TRUE,
        lineCap = "round",
        fgColor = "#428BCA",
        inputColor = "#428BCA",
        immediate=F
      ),
      #     }else{
      #  
      # }
      # }
      # }),
      knobInput(
        inputId = "nclust",
        label = "Number of Clusters",
        value = 3,
        max = 20,
        min=1,
        displayPrevious = TRUE,
        lineCap = "round",
        fgColor = "#428BCA",
        inputColor = "#428BCA",
        immediate=F
      )
        
      ,flex=c(1,1,3,3)),
    ##########################GRAPHIC TO BE RENDERED
    plotOutput("telco",click = "plot_click"),flex=c(1,8))}


```


```{r, singular spectrum analysis}
# observeEvent(input$stages_rows_selected,
#
#              )

# observeEvent(input$nclust,{
#   for()
#
#   #vis_pipe$nodes=update_nodes_cluster(vis_pipe$nodes,ExG$gssa)
#   #vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa)
#   ExG$rssa=recons(ExG$ssa,ExG$gssa[[i]])
#   # vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa)
#
# })

## NO GOOD GOGETTER: APPLY SSA WHEN YOU KNOW ON WHAT AND SPECIFIY YOUR RANK!
## NO GOOD GOGETTER: APPLY SSA WHEN YOU KNOW ON WHAT AND SPECIFIY YOUR RANK!
if(shiny_running()){
observeEvent(c(input$ssa_channel,input$stages_rows_selected,input$neigs),{
  ExG$hold=1
#  if(!is.null(input$ssa_channel) & length(input$stages_rows_selected)==1){
  if(!is.null(input$ssa_channel)){
  ### 60 Minutes maximum
  # if(ExG$stages[input$stages_rows_selected+1,2]-ExG$stages[input$stages_rows_selected,2]<60){
    # tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)],
    #                       start=ExG$stages[input$stages_rows_selected,2],
    #                       end=ExG$stages[input$stages_rows_selected+1,2]),25)
    tmp=downsample(ExG$freq[,paste0("Filtered",input$ssa_channel)],25)

    ExG$ssa=ssa.svd(tmp,30*10,1,input$neigs)

    ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$nclust,input$neigs))
    ExG$rssa=recons(ExG$ssa,ExG$gssa)
    #ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,]
    ExG$df_res=data.frame()
    for(i in 1:length(ExG$gssa)){
      df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1])))
      df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]]
      df=gather(df,key="Comp",value = "Value",-ind)
      df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),]
      df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]])))
      df$Row=i
      #df$Column=input$stages_rows_selected
      ExG$df_res=rbind(ExG$df_res,df)
      ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO!
      df=data.frame("ind"=seq(1,length(ExG$ssa$V[,1])))
      df[,paste0("Real",ExG$gssa[[i]])]=ExG$ssa$V[,ExG$gssa[[i]]]
      df=gather(df,key="Real",value = "Value",-ind)
      df=df[df$Real %in% paste0("Real",unlist(ExG$gssa[[i]])),]
      df$Real=factor(df$Real,levels = paste0("Real",unlist(ExG$gssa[[i]])))
      df$Row=i
#      df$Column=input$stages_rows_selected
      df$Column=input$stages_rows_selected
      ExG$df_res2=rbind(ExG$df_res2,df)
    }
    
  
    
  }
  ExG$hold=0
})

observeEvent(input$plot_click,{
  ExG$hold=1
  if(!is.null(input$ssa_channel) & !is.null(ExG$ssa)){
  #get the energy pattern
    if(ExG$pan==0){
      ExG$pan=c(input$plot_click$panelvar1,input$plot_click$panelvar2)
    }else{
      ##### Delete Component from Group
      ExG$gssa[[as.numeric(ExG$pan[1])]]=
        ExG$gssa[[as.numeric(ExG$pan[1])]][ExG$gssa[[as.numeric(ExG$pan[1])]]
                                           !=strsplit(ExG$pan[2],"Comp")[[1]][2]]
      ##### Add Component to Cluster
      ExG$gssa[[as.numeric(input$plot_click$panelvar1)]]=
        sort(as.numeric(append(
          ExG$gssa[[as.numeric(input$plot_click$panelvar1)]],strsplit(ExG$pan[2],"Comp")[[1]][2])))
    hlist=list()
    for(i in 1:length(ExG$gssa)){
      hlist[[i]]=ExG$gssa[[i]]
    }
    ExG$gssa=hlist
    ExG$rssa=recons(ExG$ssa,ExG$gssa)
    #ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,]
    ExG$df_res=data.frame()
    for(i in 1:length(ExG$gssa)){
      df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1])))
      df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]]
      df=gather(df,key="Comp",value = "Value",-ind)
      df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),]
      df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]])))
      df$Row=i
      # df$Column=input$stages_rows_selected
      ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO!
      ExG$df_res=rbind(ExG$df_res,df)
    }
     
      ExG$pan=0
    }
  }
  ExG$hold=0 
})

observeEvent(input$nclust,{
  ExG$hold=1
  if(!is.null(input$ssa_channel) & !is.null(ExG$ssa)){
  ### 60 Minutes maximum
    ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$nclust,input$neigs))
    ExG$rssa=recons(ExG$ssa,ExG$gssa)
#    ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,]
    ExG$df_res=data.frame()
    for(i in 1:length(ExG$gssa)){
      df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1])))
      df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]]
      df=gather(df,key="Comp",value = "Value",-ind)
      df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),]
      df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]])))
      df$Row=i
      # df$Column=input$stages_rows_selected
      ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO!
      ExG$df_res=rbind(ExG$df_res,df)
    }
    ExG$hold=0  
    }
})
}


######### THE OLD SSA WORKFLOW
# observeEvent(input$neigs,{
#   if(!is.null(input$ssa_channel) &!is.null(input$ssa_stages)){
#     if(input$ssa_stages!="All Stages"){
#   sels=strsplit(input$ssa_stages," ")[[1]][3]
#   # ExG$stages[,2] %in% sels
#
#   if(!to_day(ExG$posix,sels)){
#     i=which(ExG$stages[,2]%in%as.POSIXct(paste(as.Date(ExG$posix)+1,sels)))
#   }else{
#     i=which(ExG$stages[,2]%in%as.POSIXct(paste(as.Date(ExG$posix),sels)))
#   }
#   if(ExG$stages[i+1,2]-ExG$stages[i,2]<60){
#   tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)],start=ExG$stages[i,2],end=ExG$stages[i+1,2]),25)
#   ExG$ssa=ssa.svd(tmp,30*10,1,input$neigs)
#   #vis_pipe$nodes=update_nodes_components(vis_pipe$nodes,ExG$ssa)
#   }
#   }else{
#     tmp=downsample(ExG$freq[,paste0("Filtered",input$ssa_channel)],250)
#     arte=min(30,input$neigs)
#     ExG$ssa=ssa.svd(tmp,30,1,arte)
#    # vis_pipe$nodes=update_nodes_components(vis_pipe$nodes,ExG$ssa)
#   }
#   }
#   ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$neigs,input$nclust))
#   #vis_pipe$nodes=update_nodes_cluster(vis_pipe$nodes,ExG$gssa)
#   #vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa)
#   ExG$rssa=recons(ExG$ssa,ExG$gssa)
# })



```


<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!--   #Editable stages -->
<!--   observeEvent(input[["stages_cell_edit"]],{ -->
<!--     tmp=input[["stages_cell_edit"]] -->
<!--     if(tmp$col==2){ -->
<!--       if(length(strsplit(tmp$value,":")[[1]])>=2){ -->
<!--         if(!to_day(ExG$posix,tmp$value)){ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,tmp$value)) -->
<!--         }else{ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),tmp$value)) -->
<!--         } -->
<!--       } -->
<!--       if(length(strsplit(tmp$value,":")[[1]])==2){ -->
<!--         if(!to_day(ExG$posix,tmp$value)){ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix)+1,paste0(tmp$value,":00"))) -->
<!--         }else{ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(ExG$posix),paste0(tmp$value,":00"))) -->
<!--         } -->
<!--       } -->
<!--     } -->
<!--     else{ -->
<!--     ExG$stages[tmp$row,tmp$col]<-tmp$value -->
<!--     } -->
<!--     ExG$stages=ExG$stages[!(ExG$stages[,1] %in% c("")),] -->

<!--     # nto=nrow(ExG$stages) -->
<!--     # for(i in 1:(nto-1)){ -->
<!--     #   if(all(ExG$stages[i,]==c("",""))){ -->
<!--     #     ExG$stages=setNames(as.data.frame(ExG$stages[-i,]),colnames(ExG$stages)) -->
<!--     #     nto=nto-1 -->
<!--     #   } -->
<!--     # } -->
<!--     # if(ExG$stages[nrow(ExG$stages),1]!=""){ -->
<!--     #   ExG$stages=rbind(ExG$stages, -->
<!--     #             setNames(data.frame("",""),colnames(ExG$stages))) -->
<!--     # } -->
<!--   }) -->

<!--       # if(ExG$stages[nrow(ExG$stages),1]!="W"){ -->
<!--       # ExG$stages=rbind(ExG$stages, -->
<!--       #           setNames(data.frame("", -->
<!--       #             strsplit(as.character(last(seq(ExG$posix, -->
<!--       #                        by=1/init.srate, -->
<!--       #                        length=nrow(init.freq_filter.temp))))," ")[[1]][2] -->
<!--       #           ),colnames(ExG$stages))) -->

<!--   output$stages<-renderDT({ -->
<!--     DT::datatable(data.frame(cbind(ExG$stages[,1], -->
<!--                         strftime( -->
<!--                           ExG$stages[,2], -->
<!--                           format="%H:%M:%S")),stringsAsFactors = F), -->
<!--                   editable=T, -->
<!--                   colnames = c("Sleep State (W, S1, S2, S3, REM, A)","Time (xx:xx or xx:xx:xx)")) -->
<!--     }) -->
<!--   DTOutput("stages") -->
<!-- } -->
<!-- ``` -->




```{r}
# if(shiny_running()){
#   renderUI({
#     nomings=ExG$stages[ExG$stages[,1] %in% c("S1","S2","S3","REM"),]
#     hrv_choices=paste(nomings[,1])
#   pickerInput(
#     inputId = "hrv_stages",
#     label = "Select Stages for Heart Rate Variability",
#     choices =c(hrv_choices,"All Stages"),
#     options = list(
#     `actions-box` = TRUE,
#     size = 10
#   ),
#   multiple = F
#   )
# 
#   })
# 
# }
# 
# 
# 
# 




# df2=ExG$freq[1:(250*60*5),2]
# d=dygraph(df2)
# ento=ExG$freq[,paste0("Filtered",vis_pipe$ECG)]
#
# rownames(ento)=NULL
# ento=drop(coredata(ento))
#
#
# ento2=np_array(ento)
#
#
# # d=d %>% dyAnnotation(,text="QRS",width = 30,height=30)
#
# for(i in 1:length(res)){
#
#   d= d %>% dyAnnotation(index(df2)[
#               which(abs(index(df2)-(ExG$posix+ res/250)[i])==min(abs(index(df2)-(ExG$posix+ res/250)[i])))],
#               text="QRS",width=30,height=30)
#
#
# }
#
#
#

# #
# # hrv_res=list()
# # hrv_res=hrv_analysis(res,250,mainDir)
# #
# #

```

```{r}

# RHRV::CalculateEnergyInPSDBands(CalculatePSD( hrv_res[[1]]))
#
# RHRV::PlotMaxLyapunov(CalculateMaxLyapunov( hrv_res[[3]]))
#
#
# RHRV::CalculateDFA(hrv_res[[3]])
#
# hrv.data = CalculateCorrDim(hrv_res[[3]],indexNonLinearAnalysis=1,minEmbeddingDim=2,
#                             maxEmbeddingDim=8,timeLag=1,minRadius=1,maxRadius=15,
#                             pointsRadius=20,theilerWindow=10,corrOrder=2,doPlot=T)
# hrv.data = CalculateSampleEntropy(hrv.data,indexNonLinearAnalysis=1,doPlot=T)
# PlotSampleEntropy(hrv.data,indexNonLinearAnalysis=1)
# hrv.data = EstimateSampleEntropy(hrv.data,indexNonLinearAnalysis=1,regressionRange=c(6,10),doPlot = T)
#
# # SurrogateTest(hrv_res[[3]], indexNonLinearAnalysis = 1,
# #                         significance = 0.05, oneSided = FALSE,
# #                         K = 5, useFunction = timeAsymmetry2)
# ## End(Not run)



if(shiny_running()){
  observeEvent(input$ana_button,{
  
  if(is.null(input$eeg_ana)){
    tmp_bp=rel_bp(coredata(ExG$freq)[,paste0("Filtered",input$eeg_ana)])
    ExG$bandpower=as.xts((tmp_bp[,1:5]/tmp_bp[,6])*100,seq(ExG$posix, by=input$L, length=nrow(tmp_bp)))

  ## selected channel
  # if(!is.null(graph_data$EEG[graph_data$EEG %in% input$disp_chan])
  #    & "Sleep Spindles" %in% input$disp_event){
  #   vis_pipe$EEG[vis_pipe$EEG %in% input$disp_chan]
  ## Limit stages
  ExG$spindles=NULL
  res2=data.frame()
  
  for(i in 1:(nrow(ExG$stages)-1)){
    if((ExG$stages[i,1]%in% c("S1","S2","S3"))){
      ## For last entry take time to end, else take time to next stage
      if(i!=(nrow(ExG$stages)-1)){tmp=window(ExG$freq,start=ExG$stages[i,2],end=ExG$stages[i+1,2])
      }else{tmp=window(ExG$freq,start=ExG$stages[i,2],end=last(index(ExG$freq)))}
      
      ## Collect Sleep Spindles by Yasa
      res<-data.frame(
        py$sleep_spindles(tmp[,paste0("Filtered",eeg_ana)],ExG$srate),stringsAsFactors = F
        )[,c("Start","Duration","Oscillations")]

      res2=rbind(res2,data.frame(Start=ExG$stages[i,2]+res$Start,stringsAsFactors = F))
    }
  }
  ExG$spindles=setNames( 
    data.frame(rep("Spindle",nrow(res2)),res2$Start,stringsAsFactors = F),c("Event","Time"))
  }
})
}

```


### Data Viewer & PDF - data is downsampled based on window range (a) more than 30 minutes (b) between 30 minutes and 20 seconds (c) less than 20 seconds

```{r}

if(shiny_running()){

renderTable({
  res=round(unlist(lapply(ExG$freq,function(x)nrow(x)/(ExG$srate*60)))[1],0)
res=c("Total",res)

df=data.frame("Stage"=ExG$stages[,1],"Duration"=c(as.numeric(difftime(c(ExG$stages[-1,2],last(index(ExG$freq))),ExG$stages[,2],units = "mins"))))

res2=ddply(df,"Stage",function(x)sum(x[,2]))
res2$Stage=as.character(res2$Stage)
res2$V1=round(res2$V1,0)
df_res=rbind(setNames(res,colnames(res2)),res2)

res3=t(py$glob_bp(array(coredata(ExG$freq[,paste0("Filtered",input$bp_channel_sel)])),ExG$srate))

res3=round(res3[1:6,]*100,1)
df_res=rbind(df_res,setNames(data.frame(names(res3),as.matrix(res3)),colnames(df_res)))
res4=nrow(ExG$spindles)
df_res=rbind(df_res,setNames(data.frame("Sleep Spindles",res4),colnames(df_res)))

res5=c("Explained Variance SSA",round(sum(contributions(ExG$ssa)*100),1))


       
ExG$summ=rbind(df_res,setNames(res5,colnames(df_res)))
ExG$summ
})
}else{
      
kable(EXG$summ)
  
}



```


```{r}
if(shiny_running()){
observeEvent(input[["dygraph_click"]],{
  ## Add new row with inital Value Artifact to the EEG staging on click in graphic
  ## Get the Date
  if("Stages" %in% input$disp_event){
  date_click=strsplit(input[["dygraph_click"]][["x"]],"T")[[1]][1]
  ## Get the Time, without the Z
  time_click=strsplit(strsplit(input[["dygraph_click"]][["x"]],"T")[[1]][2],"Z")[[1]][1]
  ## Adjust format and timezone
  date_time_click=as.POSIXct(paste(date_click,time_click,format="%Y-%m-%d %H:%M:%OS"))+60*60
  ExG$stages=
    data.frame(rbind(ExG$stages,
          setNames(data.frame("A",
                              date_time_click,
                              stringsAsFactors = F),
                   colnames(ExG$stages))))
  }
})



observeEvent(input$downRater,{
  if(input$downRater!=0){
  downList=c("A","W","REM","S1","S2","S3")
  if(any(ExG$stages[as.numeric(input$downRater),1] %in% downList)){
     if(ExG$stages[as.numeric(input$downRater),1]!="S3"){
     ExG$stages[as.numeric(input$downRater),1]=
       downList[which(downList %in% ExG$stages[as.numeric(input$downRater),1] )+1]
     }else{
       ExG$stages=ExG$stages[-as.numeric(input$downRater),]
     }
  }
  }
})

observeEvent(input$upRater,{
  if(input$upRater!=0){
  upList=c("S3","S2","S1","REM","W","A")
  if(any(ExG$stages[as.numeric(input$upRater),1] %in% upList)){
    if(ExG$stages[as.numeric(input$upRater),1]!="A"){
      ExG$stages[as.numeric(input$upRater),1]=
      upList[which(upList %in% ExG$stages[as.numeric(input$upRater),1] )+1]
    }else{
      ExG$stages=ExG$stages[-as.numeric(input$upRater),]
    }
  }
  }
})
}

```

```{r}

## interactive update window

if(shiny_running()){
observeEvent({c(input[["dygraph_date_window"]],
                input$disp_chan,
               input$disp_event,
               input$disp_ssa)},
  {
  ##Check current display ranges range,timezone conversion etc.
  r1=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[1]]),collapse = " "))+60*60
  r2=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[2]]),collapse = " "))+60*60
  range=c(r1,r2)
  d_range=difftime(range[2],range[1],units="secs")
  resize=F
  redat=F
  ## Resolution changed? "bird" -hour, "time"-minute, "detail" -second
  ## if so data need to be resampled resize=T
  if(d_range<20 & ExG$sight!="detail"){
    resize=T
    ExG$sight="detail"
  }
  if((d_range>=20 ) & ExG$sight!="time"){
    resize=T
    ExG$sight="time"
  }
  # if((d_range>=60*30 & d_range<60*60*24) & ExG$sight!="bird"){
  #   resize=T
  #   ExG$sight="bird"
  # }

  ## Select Channels to display - mutually exclusive for Source and Channel
  if(!is.null(input$disp_chan)){
    ## Check for mutually exclusive groups - not working
    if(!all(paste0("Filtered",input$disp_chan) %in% ExG$orig.chan)|
       !all(paste0("Filtered",input$disp_chan) %in% ExG$orig.chan))newdata=T
  }else{
    if(!is.null(colnames(ExG$orig.chan))){newdata=T}else{newdata=F}
  }

  #if anything is not displayed already
  if(newdata){
    redat=T
    tmp=xts(rep(NA,length(index(ExG$freq))),index(ExG$freq))
    colnames(tmp)="Empty"
    if(!is.null(input$disp_chan)){
      for(i in 1:length(input$disp_chan)){
          tmp=merge(tmp,ExG$freq[,paste0("Filtered",input$disp_chan[i])])
      }
    ExG$orig.chan=tmp[,colSums(is.na(tmp))<1000]
    }else{
    ExG$orig.chan=tmp
    }
  }


  newclust=(!all(input$disp_ssa %in% colnames(ExG$orig.ssa)))|
    (!all(colnames(ExG$orig.ssa) %in% input$disp_ssa))

  if(redat|newclust){
    redat=T
    tmp=ExG$orig.chan
    # if(input$clust_disp){
      # ExG$rssa<-recons(ExG$ssa,ExG$gssa,stacked = F)
    # }else{
    #   ExG$rssa<-recons(ExG$ssa,ExG$gssa,separate = T)
    #}
    for(i in input$disp_ssa){
      tmp=merge(tmp, ExG$rssa[,i])
    }
    ExG$orig.ssa=tmp
  }

  ## Check if alpha band is already displayed, not clean
  test_q1=(!any(grepl("Alp",colnames(ExG$orig.disp))) & "Bandpower" %in% input[["disp_event"]])|
      (any(grepl("Alp",colnames(ExG$orig.disp))) & !("Bandpower" %in% input[["disp_event"]]))

  # Check not implemented
  # test_q2=(all(graph_data$EEG %in% colnames(ExG$orig.disp)) & !("Raw Signal" %in% input$disp_event))|
  #               (!all(graph_data$EEG %in% colnames(ExG$orig.disp)) & ( "Raw Signal" %in% input$disp_event))

  if(test_q1|redat){
    # if(input$clust_disp){}
      redat=T
      tmp=ExG$orig.ssa
      # if("Raw Signal" %in% input$disp_event){
      #   tmp=merge(tmp,ExG$ts[,unlist(lapply(strsplit(colnames(ExG$orig.chan),"Filtered"),function(x)x[[2]]))])}
      if("Bandpower" %in% input$disp_event){tmp=merge(tmp,ExG$bandpower)}
      ExG$orig.disp=tmp
  }

  ## Update Resolution of data
  if(range[2]>min(last(index(ExG$orig.disp)),ExG$resol[2])||
        range[1]<max(first(index(ExG$orig.disp)),ExG$resol[1])||
     resize||redat){
    ## if new data selection, dont change resolution borders
    if(!redat){
      r1=max(first(index(ExG$orig.disp)),range[1]-10*d_range)
      r2=min(last(index(ExG$orig.disp)),range[2]+10*d_range)
    }else{
      # a=range[1]
      # b=range[2]
    }
    redat=F
      #Seconds down to full
    if(ExG$sight=="detail"){
      if(r1!=first(index(ExG$orig.disp))){
        ## downsample out of scope to minutes, rest complete
          tmp=rbind(
            downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=r1),60*250*3),
            window(ExG$orig.disp,start=r1,end=r2))
      }else tmp=window(ExG$orig.disp,start=r1,end=r2)
      if(r2!=last(index(ExG$orig.disp))){
          tmp=rbind(tmp,
          downsample(window(ExG$orig.disp,start=r2,end=last(index(ExG$orig.disp))),250*60*3))}
      }
        # Minutes , down to seconds
    if(ExG$sight=="time"){
        if(r1!=first(index(ExG$orig.disp))){
          ## downsample out of scope to minutes, rest to seconds
          tmp=rbind(
              downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=r1),250*60*3),
              downsample(window(ExG$orig.disp,start=r1,end=r2),250*10))
          }else tmp=downsample(window(ExG$orig.disp,start=r1,end=r2),250)
          if(r2!=last(index(ExG$orig.disp))){
            tmp=rbind(tmp,
            downsample(window(ExG$orig.disp,start=r2,end=last(index(ExG$orig.disp))),250*60*3))}
    }
      # hours down to minutes
      # if(ExG$sight=="bird"){
      #   if(a!=first(index(ExG$orig.disp))){
      #       tmp=rbind(
      #         downsample(window(ExG$orig.disp,start=first(index(ExG$orig.disp)),end=a),250*60*10),
      #         downsample(window(ExG$orig.disp,start=a,end=b),250*60))
      #       }else{
      #           tmp=downsample(window(ExG$orig.disp,start=a,end=b),250*60)
      #         }
      #     if(b!=last(index(ExG$orig.disp))){
      #       tmp=rbind(tmp,
      #       downsample(window(ExG$orig.disp,start=b,end=last(index(ExG$orig.disp))),250*60*10))
      #       }
      # }
      ExG$resol=c(r1,r2)
     ExG$disp=tmp
    }
})
}
```


```{r}


# if(shiny_running()){
#   # dropdown(
#   # tags$h3("List of Input"),
#   renderUI({
#     chansels=colnames(ExG$ts)
#   pickerInput(
#     inputId = "disp_chan",
#     label = "Select Channels/Sources for Glimpse",
#     choices =chansels,
#     options = list(
#     `actions-box` = TRUE,
#     size = 10,
#     `selected-text-format` = "count > 3"
#   ),
#   multiple = TRUE
#   )
#   })
# }
#   #,
# if(shiny_running()){
# 
# pickerInput(
#     inputId = "disp_event",
#     label = "Select Events/Filters for Glimpse",
#     choices = c("Raw Signal","Bandpower","Stages","Events"),
#     options = list(
#     `actions-box` = TRUE,
#     size = 10,
#     `selected-text-format` = "count > 3"
#   ),
#   multiple = TRUE
#   )
# }
#   #,
# # if(shiny_running()){
# #
# # pickerInput(
# #     inputId = "excl_sigs",
# #     label = "Select Exclusion Periods for Glimpse",
# #     choices = c("W","S1","S2","S3","REM"),
# #     options = list(
# #     `actions-box` = TRUE,
# #     size = 10,
# #     `selected-text-format` = "count > 3"
# #   ),
# #   multiple = TRUE
# #   )
# # }
# if(shiny_running()){
# renderUI({
# sel_choices=colnames(ExG$rssa)
# pickerInput(
#     inputId = "disp_ssa",
#     label = "Select Clusters/Components for Glipse",
#     choices = sel_choices,
#     options = list(
#     `actions-box` = TRUE,
#     size = 10,
#     `selected-text-format` = "count > 3"
#   ),
#   multiple = TRUE
#   )
# 
# })
# }
# 
# if(shiny_running()){
#   switchInput(inputId = "sep_chan", label = "parallel Channels", value=F)
# }
# 
# 


```

```{r}
if(shiny_running()){
  downloadButtonRmd("downloadReport",label="Download PDF")
}

# renderPrint(print(getwd()))

if(shiny_running() ){
output$downloadReport <- downloadHandler(
  filename = function() {
    paste('MentaLab', sep = '.', PDF = 'pdf')
  },
  content = function(file){
    file.copy(paste0(mainDir,"/Dashboard.Rmd"),
              paste0(mainDir,"/Report.Rmd"), overwrite = TRUE)
    # nok=isolate(ExG$stages)
    EXG<<-list()
    EXG$stages=ExG$stages
    EXG$df_res=ExG$df_res
    EXG$spindles=ExG$spindles
    EXG$hrv=ExG$hrv
    EXG$summ=ExG$summ
    out=rmarkdown::render(paste0(mainDir,"/Report.Rmd"), pdf_document(),runtime="static")
    file.rename(out, file)
  }
)}

```


