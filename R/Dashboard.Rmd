---
title: "Statexpres's: Rapid Development with Mentalab Explore - Advanced Signal Exploration in Sleep EEG (statexpres.com/sleep)"
output:
  flexdashboard::flex_dashboard:
    storyboard: TRUE
    always_allow_html: yes
  pdf_document:
    classoption: landscape
    documentclass: ar-1col
    header-includes: \usepackage{fancyhdr,tabu, courier,chngcntr,longtable, graphicx,float,natbib,geometry}
    keep_tex: TRUE
    fig_caption: yes
    number_sections: yes
    always_allow_html: yes
runtime: shiny
---

<!-- <style> -->
<!--   .storyboard-nav .sbframelist { -->
<!--         margin: 0 auto; -->
<!--         width: 94%; -->
<!--         height: 90px; -->
<!--         overflow: hidden; -->
<!--         text-shadow: none; -->
<!--         margin-bottom: 3px; -->
<!--         margin-top: 3px; -->
<!--   } -->
<!--   .storyboard-nav .sbnext, .storyboard-nav .sbprev { -->
<!--         float: left; -->
<!--         width: 20px; -->
<!--         height: 20px; -->
<!--         font-size: 20px; -->
<!--   } -->
<!-- </style> -->

```{r dependencies, include=FALSE}

## Create environment and folder structure, load neccesary files and packages

### neccessary linux packages and folders and a speedup for RSSA!
## sudo apt-get install tk-dev
## sudo apt-get install fftw-dev
## sudo apt-get install libcgal-dev libglu1-mesa-dev libglu1-mesa-dev

# create_folder<-function(x)ifelse(!dir.exists(file.path(getwd(), x)), dir.create(file.path(getwd(), x)), FALSE)
# create_folder('Data')
# create_folder('Report')
# create_folder('Plots')
# create_folder('EDF')


## python config

reticulate::use_python(reticulate::py_config()[[1]],required = T)
library(reticulate)
## Setup Python in Reticulate
#reticulate::repl_python()
# conda_create("final")
#use_condaenv("final")
# reticulate::repl_python()
# explorepy <- reticulate::import_from_path("explorepy",path="C:/Users/royde/Anaconda3/Lib/site-packages")
# visbrain<-reticulate::import("visbrain",delay_load = T)
# scipy <- reticulate::import("scipy",delay_load = T)
# numpy <- reticulate::import("numpy",delay_load = T)
#conda_install("MENTALAB", "explorepy")

## load R packages - watch for broken dependencies!
loadpackage<-function(x){
  for(i in x){
    ## if not installed
    if(!(i %in% rownames(installed.packages()))){
      if(i=="eegUtils"){
        ## make exemption for eegUtils for install from github
        eval(parse(text=paste0("remotes::install_github(\"","craddm/eegUtils","\", repos=\'http://cran.us.r-project.org\')")))
      }else{
        # install missing packages
        eval(parse(
          text=paste0("install.packages(\"",i,"\", repos=\'http://cran.us.r-project.org\')")))
        # and load them
        eval(parse(
          text=paste0("library(\"",i,"\")")))}
    }
    else{
      # if installed load packages
      eval(parse(text=paste0("library(\"",i,"\")")))}
    }
}

## Load install R packages
#"eegUtils"
loadpackage(c("plyr","dplyr","ggplot2","knitr","broom","ggfortify","kableExtra","remotes","xts","dlm","forecast","signal","rmarkdown","plotly","visNetwork","Rssa","RHRV","data.table","DT","shinyTime","shinyWidgets","dygraphs","ggplotify","cowplot","tidyr","here"))

# set default RStudio code-chunk parameters
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, error = FALSE, 
                      fig.align = 'center', fig.pos = 'htbp', results = 'asis')
options(scipen = 999)# no exponentials-plain values
options(shiny.maxRequestSize=5000*1024^2)#Max Upload Size
options(shiny.Trace=T)

## Default output format (shiny-html first, statitic-Pdf later)
if(!is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))){
  outputoption<<-knitr::opts_knit$get("rmarkdown.pandoc.to")
}else{outputoption<<-"html"}

shiny_running = function()identical(rmarkdown::metadata$runtime, 'shiny')&outputoption!="latex"

# if(!shiny_running()){
#   reactiveValues<-function(...)list(...)
# }

if(outputoption!="html"){
  if(outputoption!="latex"){
  mainDir<-getwd()
  }else{
    mainDir<-getwd()
    # mainDirsplit<-strsplit(mainDir,"/")[[1]]
    # mainDir<-paste(mainDirsplit[-length(mainDirsplit)],collapse="/")
    
  }
}else{
  if(outputoption=="html")
    mainDir<-here::here()
    mainDir<-"D:/Users/royde/Nextcloud/Studium/Mathematik/Bachelorarbeit/EEG_derivat/"
    #demoMode=T
    # mainDir<-"/home/sweiss/Mentalab/"
}

# if(!shiny_running()){
#   reactiveValues<-function(...)list(...)
# }
```

```{r}
## Setup Python in Reticulate
#reticulate::repl_python()
# conda_create("final")
#use_condaenv("final")
# reticulate::repl_python()
# explorepy <- reticulate::import_from_path("explorepy",path="C:/Users/royde/Anaconda3/Lib/site-packages")
# visbrain<-reticulate::import("visbrain",delay_load = T)
# scipy <- reticulate::import("scipy",delay_load = T)
# numpy <- reticulate::import("numpy",delay_load = T)
#conda_install("MENTALAB", "explorepy")
```

```{r,define_functions}
#py_install(c("py-ecg-detectors","yasa","explorepy"),pip=T)
reticulate::source_python(paste0(mainDir,"/EEG.py"))
# source(paste0(mainDir,"/helpers.R"))
# source(paste0(mainDir,"/ui.R"))
# source(paste0(mainDir,"/fixed_frequency.R"))
# source(paste0(mainDir,"/start_script_1.R"))


```


<!-- <!-- \lhead{MentaLab's Signal Evaluation \linebreak {\leftmark}  } --> -->

<!-- \clearpage -->

<!-- <!-- ### Signal Source --> -->


<!-- <!-- \begin{tcolorbox}[colback=lhi!30,%gray background --> -->
<!-- <!--                 colframe=lhi!60,% black frame colour --> -->
<!-- <!--                 arc=1mm, auto outer arc,] --> -->
<!-- <!-- MentaLab's Signal Evaluation employes recent signal processing tools, to evaluate ECG and EEG data.     --> -->
<!-- <!-- Furthermore it holds relevant citation and customizable output formats.     --> -->
<!-- <!-- It is extandable by Python and R data analysis methods and curated by professional biostatisticians and medical experts.     --> -->
<!-- <!-- \end{tcolorbox} --> -->

<!-- ### Input - data is assumed to be in Voltage and will be converted based on biosource, initial rounding to one microvolt. -->
<!-- <!-- {.sidebar} --> -->

<!-- ```{r} -->


<!-- if(shiny_running()){ -->
<!--   output$dygraph<- -->
<!--     renderDygraph({ -->
<!--       # if(Disp$newfile){ -->
<!--       #     d<-dygraph(ExG$disp) %>% dyAxis("y", label = "Electric Potential (EEG-uV / E(CMO)G-mV)",valueRange=c(-50,50)) %>% -->
<!--       #       dyRangeSelector(height = 90,retainDateWindow=F) %>%  -->
<!--       #     dyOptions(axisLineWidth = 1.5, drawGrid = FALSE) %>% -->
<!--       #       dyLegend(show = "never") -->
<!--       #     Disp$newfile=F -->
<!--       # }else{ -->
<!--         ## Seperate Channel by normalizing to IQR and adding a positional vector -"the matrix" -->
<!--         d<-dygraph(Disp$disp) %>% dyAxis("y", label = "Electric Potential (V)",valueRange=c(-50,50)) %>% -->
<!--           dyRangeSelector(height = 90,retainDateWindow=!(Disp$newfile)) %>% dyLegend(show = "never") %>%  -->
<!--           dyOptions(axisLineWidth = 1.5, drawGrid = FALSE,connectSeparatedPoints=T) %>% dyCallbacks(  -->
<!--             annotationClickHandler=  -->
<!--           "function(ann, point, dg, event){ -->
<!--           ann.div.style.backgroundColor =  '#ddd'; -->
<!--           var message=ann.text; -->
<!--           Shiny.onInputChange('downRater',0); -->
<!--           Shiny.setInputValue('downRater',message);}") -->
<!--     #} -->
<!--     if("Bandpower" %in% input$disp_event){ -->
<!--       # Take Bandpower columns - always last ones -->
<!--       dn<-colnames(ExG$disp)[(ncol(ExG$disp)-4):(ncol(ExG$disp))] -->
<!--         for(i in 1:length(dn)){ -->
<!--           #display them on other y axis -->
<!--           d<-d %>% dySeries(dn[i], axis = 'y2',stepPlot = F, -->
<!--                    color=c("#bcbddc","#9e9ac8","#807dba","#6a51a3","#4a1486")[i])%>%  -->
<!--             dyAxis("y2", label = "Bandpower (%)",valueRange=c(0,100)) -->
<!--         } -->
<!--     } -->
<!--     if("Stages" %in% input$disp_event){ -->
<!--       for(i in 1:(nrow(ExG$stages))){ -->
<!--         if(any(ExG$stages[i,1] %in% c("W","S1","S2","S3","REM","A") )){ -->
<!--           ## Get the closest index value of the displayed time series -->
<!--           ## Write the annotation there - otherwise does not show an annotation bc timestamp might be missing -->
<!--             d= d %>% dyAnnotation(index(ExG$disp)[ -->
<!--               which(abs(index(ExG$disp)-ExG$stages[i,2])==min(abs(index(ExG$disp)-ExG$stages[i,2])))], -->
<!--               text=ExG$stages[i,1],attachAtBottom =T,tooltip = as.character(i),width=30,height=30) -->
<!--           } -->
<!--       } -->
<!--     } -->
<!--     if("Sleep Spindles" %in% input$disp_event){ -->
<!--       for(i in 1:(nrow(ExG$spindles))){ -->
<!--         ## same as above, closest existing timestamp, events are the Sleep Spindles only atm -->
<!--         d= d %>% dyAnnotation(index(ExG$disp)[ -->
<!--           which(abs(index(ExG$disp)-ExG$spindles[i,2])==min(abs(index(ExG$disp)-ExG$spindles[i,2])))], -->
<!--           text="Sp",width=20,height=20) -->
<!--       } -->
<!--     } -->
<!--       if("QRS-Complex" %in% input$disp_event){ -->
<!--       for(i in 1:(nrow(ExG$qrs))){ -->
<!--         ## same as above, closest existing timestamp, events are the Sleep Spindles only atm -->
<!--         d= d %>% dyAnnotation(index(ExG$disp)[ -->
<!--           which(abs(index(ExG$disp)-ExG$qrs[i,2])==min(abs(index(ExG$disp)-ExG$qrs[i,2])))], -->
<!--           text="QRS",width=20,height=20) -->
<!--       } -->
<!--         } -->
<!--     d -->
<!--   }) -->
<!-- } -->

<!-- ### FIRST PANEL UI ELEMENTS PLACEMENT -->
<!-- if(shiny_running()){ -->
<!--   fillCol( -->
<!--     fillRow( -->
<!--       actionButton("upload","Upload new Data ... "), -->
<!--         renderUI({ -->
<!--           chansels=colnames(ExG$ts) -->
<!--           pickerInput( -->
<!--           inputId = "disp_chan", -->
<!--           choices =chansels, -->
<!--           options = list(title = "Channels", -->
<!--                          `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"), -->
<!--           multiple = TRUE -->
<!--           ) -->
<!--         }), -->
<!--         pickerInput( -->
<!--           inputId = "disp_event", -->
<!--           choices = c("Bandpower","Stages","Sleep Spindles","QRS-Complex"), -->
<!--           options = list(title = "Events", -->
<!--                          `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"), -->
<!--           multiple = TRUE -->
<!--           ), -->
<!--         renderUI({ -->
<!--           sel_choices=colnames(ExG$rssa) -->
<!--           pickerInput( -->
<!--             inputId = "disp_ssa", -->
<!--             choices = sel_choices, -->
<!--             options = list(title = "Clusters", -->
<!--                            `actions-box` = TRUE,size = 8,`selected-text-format` = "count > 3"), -->
<!--           multiple = TRUE -->
<!--           ) -->
<!--         }),flex=c(1,2,2,2)), -->
<!--     ### INPUTS FINISHED -> NEXT COLUMN: GRPAHIC -->
<!--     dygraphOutput("dygraph") -->
<!--     ,flex = c(1,10)) -->
<!-- } -->


<!-- ### FOR PDF -->
<!-- # if(!shiny_running()){ -->
<!-- #   ## STATIC DISPLAY HYPNOGRAM -->
<!-- #   # it's W, REM, S1, S2, S3, -->
<!-- #   # d=data.frame(x=c(1,2,4,5,7,8,9), y=c(1,2,3,5,6,7,9)) -->
<!-- #   d=ExG$stages -->
<!-- #   d[,1]=factor(d[,1],levels = c("S3","S2","S1","REM","W","A")) -->
<!-- #   colnames(d)=c("y","x") -->
<!-- # ggplot() + -->
<!-- # geom_step(data=d, mapping=aes(x=x, y=y),group=1)+theme_classic() -->
<!-- # } -->

<!-- ``` -->


<!-- ```{r,file_observer} -->
<!-- ## Include Export and Import Options, funcitons is faulty -->
<!-- ## DATA upload actions, currently only EDF and csv -->
<!-- if(shiny_running()){ -->
<!-- observeEvent(input$static_data,{ -->
<!--       if(any(grepl(".edf",input$static_data))){ -->
<!--         tmp=import_raw(input$static_data$datapath) -->
<!--         #tmp=import_raw(paste0(mainDir,"/Data/slp03.edf")) -->
<!--         ExG$srate=tmp[["srate"]] -->
<!--         tmp=tmp[["signals"]]/1000 -->
<!--         Disp$posix=as.POSIXct(paste(input$rec_date,input$rec_time),tz="CET") -->
<!--         ExG$ts=as.xts(data.frame(tmp), -->
<!--                       seq(Disp$posix,  -->
<!--                           by=1/ExG$srate, length=nrow(data.frame(tmp)))) -->

<!--       } -->
<!--       if(any(grepl(".csv",input$static_data))){ -->
<!--         tmp=round(data.frame(fread(input$static_data$datapath)[,-1]*1000),0) -->
<!--         ExG$srate=as.numeric(input$srate) -->
<!--         Disp$posix=as.POSIXct(paste(input$rec_date,input$rec_time),tz="CET") -->
<!--         ExG$ts=as.xts(tmp, -->
<!--                       seq(Disp$posix,  -->
<!--                           by=1/ExG$srate, length=nrow(data.frame(tmp)))) -->

<!--       } -->
<!--       if(any(grepl(".BIN",input$static_data))){ -->
<!--         #ExG$a=1 -->
<!--         #file.copy(input$static_data$datapath,paste0(mainDir,"Data/")) -->
<!--         py$import_explorepy(input$static_data$datapath) -->
<!--         # file.copy(input$static_data$datapath,paste0(mainDir,"Data/")) -->
<!--         tmp=fread(paste0(mainDir,"/0_exg.csv")) -->
<!--         ExG$srate=as.numeric(input$srate) -->
<!--         Disp$posix=as.POSIXct(paste(input$rec_date,input$rec_time),tz="CET") -->
<!--         ExG$ts=as.xts(data.frame(tmp), -->
<!--                        seq(Disp$posix,  -->
<!--                            by=1/ExG$srate, length=nrow(data.frame(tmp)))) -->

<!--       } -->
<!--       # get column names -->

<!--       graph_data$nodes=update_nodes(base.nodes,tmp) -->
<!--       biosigs=subset(graph_data$nodes,group=="biological") -->
<!--       physigs=subset(graph_data$nodes,group=="physical") -->
<!--       digsigs=subset(graph_data$nodes,group=="digital") -->
<!--       # -->

<!--       graph_data$edges=setNames(data.frame(matrix(ncol = 3, nrow = 0)), c("from", "to","id")) -->
<!--       ExG$freq=ExG$ts -->
<!--       colnames(ExG$freq)=paste0("Filtered",colnames(ExG$ts)) -->
<!--       Disp$orig.chan=downsample(ExG$freq,60*15) -->
<!--       Disp$orig.ssa=downsample(ExG$freq,60*15) -->
<!--       Disp$orig.disp=downsample(ExG$freq,60*15) -->
<!--       ExG$disp=downsample(ExG$freq,60*15) -->
<!--       Disp$newfile=T -->
<!--       ExG$stages= -->
<!--         data.frame( -->
<!--   "Sleep State (W, S1, S2, S3, REM)"=c("W"), -->
<!--   "Time (xx:xx or xx:xx:xx)"=as.POSIXct(Disp$posix), -->
<!--                        stringsAsFactors = F) -->

<!--       # -->
<!--       # Disp$orig.disp=tmp -->
<!--       # ## reset UI elements below -->
<!--       # Disp$sight="bird" -->
<!--        a=first(index(ExG$freq)) -->
<!--        b=last(index(ExG$freq)) -->
<!--       # tmp=downsample(window(Disp$orig.disp,start=a,end=b),250*60) -->
<!--        Disp$resol=c(a,b) -->
<!--       # ExG$disp=tmp -->
<!--       # Disp$newfile=T -->
<!--     ExG$stages=data.frame("Sleep State (A, W, S1, S2, S3, REM)"="W", -->
<!--                         "Time (xx:xx or xx:xx:xx)"=first(seq(Disp$posix,by=1/ExG$srate,length=nrow(ExG$ts))), -->
<!--                         stringsAsFactors = F) -->
<!--     graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1) -->
<!--       graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2) -->
<!--       graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3) -->
<!--       graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4) -->
<!--   }) -->

<!-- # observeEvent(input$srate,{ -->
<!-- #   ExG$srate=input$srate -->
<!-- # }) -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!-- observeEvent(input$upload,{ -->
<!--   showModal(modalDialog( -->
<!--     dateInput("rec_date", label="Start Date", value = NULL, min = NULL, max = NULL, -->
<!--   format = "yyyy-mm-dd", startview = "month", weekstart = 0, -->
<!--   language = "en", width = NULL, autoclose = TRUE, -->
<!--   datesdisabled = NULL, daysofweekdisabled = NULL), -->
<!--   textInput("rec_time", "Start Time (xx:xx or xx:xx:xx)", value = strftime(Sys.time(), format = "%H:%M"), width = NULL, -->
<!--   placeholder = NULL), -->
<!--   numericInput("srate","Sampling Frequency",value=250,min=1,max=1000), -->
<!--   fileInput("static_data", "Upload Data (EDF/CSV/BIN):", multiple = F, accept = c(".csv",".edf",".BIN"), -->
<!--       width = NULL, buttonLabel = "Browse...", -->
<!--       placeholder = "No file selected"), -->
<!--   renderTable(head(ExG$ts)),size="l" -->
<!--   ) -->
<!-- ) -->
<!-- }) -->
<!-- } -->

<!-- ``` -->


<!-- ### Source & Filter - add edges from channels to biosources, select biosources and apply filter settings -->


<!-- ```{r} -->
<!-- # tag$script('$(document).on("keypress",function(e) { -->
<!-- #               Shiny.onInputChange("keyinput",e.which); -->
<!-- #              })') -->


<!-- if(shiny_running()){ -->
<!-- output$freq_band<-renderPlot({ -->

<!--  p=ggplot()+geom_bar( -->
<!--         data=data.frame(freq=c(seq(0,4.9,0.1),seq(5,49,1),seq(50,250,10)),amp=rep(1,116)), -->
<!--         # aes(x=time,y=amp,group=Comp,color=Comp))+ -->
<!--         aes(x=freq,y=amp))+ -->
<!--         theme_classic()+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none") -->

<!--  if(sum(dim(ExG$band_comp))!=0){ -->

<!-- # Add text -->
<!-- p = p + geom_text(data=ExG$band_comp, aes( x=x, y=y, label=label), -->
<!--            color="black",  -->
<!--            size=7 , angle=45, fontface="bold" ) -->

<!--  } -->
<!--  p -->
<!-- }) -->
<!-- } -->

<!-- observeEvent(input$click_plot,{ -->

<!--   if(input$click_plot$x<5){ -->
<!--   ExG$band_comp<-rbind(ExG$band_comp, -->
<!--                        data.frame( -->
<!--   x = c(as.numeric(round(input$click_plot$x),1)), -->
<!--   y = c(1), -->
<!--   label = c(as.character(round(input$click_plot$x,1))) -->
<!--   )) -->
<!--   } -->
<!--   if(input$click_plot$x<50 & input$click_plot$x>=5){ -->
<!--   ExG$band_comp<-rbind(ExG$band_comp, -->
<!--                        data.frame( -->
<!--   x = c(as.numeric(round(input$click_plot$x),0)), -->
<!--   y = c(1), -->
<!--   label = c(as.character(round(input$click_plot$x,0))) -->
<!--   )) -->
<!--   } -->
<!--     if(input$click_plot$x>=50){ -->
<!--   ExG$band_comp<-rbind(ExG$band_comp, -->
<!--                        data.frame( -->
<!--   x = c(as.numeric(round(input$click_plot$x/10),0)*10), -->
<!--   y = c(1), -->
<!--   label = c(as.character(round(input$click_plot$x/10,0)*10)) -->
<!--   )) -->
<!--   } -->


<!-- }) -->


<!-- ``` -->


<!-- ```{r,visnetwork} -->

<!-- if(shiny_running()){ -->
<!--   ## Graph Network - fontawesome not working, some manipulations should be disaabled, clusters not displayed -->
<!--   output$visnet<-renderVisNetwork({ -->
<!--     visNetwork(graph_data$nodes,graph_data$edges) %>% -->
<!--       visOptions(nodesIdSelection = list(enabled=T,values = c(1:4)),manipulation = list( -->
<!--     enabled= T, -->
<!--     initiallyActive= T, -->
<!--     addNode= F, -->
<!--     addEdge= T, -->
<!--     editEdge= F, -->
<!--     deleteNode= F, -->
<!--     deleteEdge= T -->
<!--     )) %>%visInteraction(multiselect=T, -->
<!--                          dragNodes = T, -->
<!--                          dragView = T, -->
<!--                          zoomView = T) %>% -->
<!--       visGroups(groupname = "digital", shape = "icon", -->
<!--             icon = list(code = "f31b", size = 75,face = 'Ionicons',color="black")) %>% -->
<!--       visGroups(groupname = "physical", shape = "icon", -->
<!--                 icon = list(code = "f3a7", size=75,face = 'Ionicons',color="red"))%>% -->
<!--       visGroups(groupname = "biological", shape = "icon", -->
<!--                 icon = list(code = c('f493'), size=75,color="green",face = 'Ionicons'))  %>% -->
<!--       visGroups(groupname = "Component", shape = "icon",                 -->
<!--                 icon = list(code = "f2e9", size = 25,color="orange",face = 'Ionicons')) %>% -->
<!--       visGroups(groupname = "Cluster", shape = "icon", -->
<!--                     icon= list(code = "f25c", size = 75,color="blue",face= 'Ionicons')) %>% addIonicons()%>% visEdges(arrows = "to") %>%  -->
<!--   visHierarchicalLayout( levelSeparation = 200,nodeSpacing=50,treeSpacing=100) -->

<!--   }) -->

<!--   visNetworkOutput("visnet") -->
<!-- } -->

<!-- # visEvents(select = "function(nodes) { -->
<!-- #                 Shiny.onInputChange('current_node_id', nodes.nodes); -->
<!-- #                 ;}") %>% -->
<!-- # %>% -->
<!-- #                  visEvents(select = "function(nodes) { -->
<!-- #                 Shiny.onInputChange('current_node_id', nodes.nodes); -->
<!-- #                 ;}") -->

<!--   # observeEvent(input$current_node_id, { -->
<!--   #   visNetworkProxy("visnet") %>% -->
<!--   #     visGetNodes() -->
<!--   # }) -->

<!-- if(shiny_running()){ -->
<!-- ## Watch Manipulation of network - also implement renaming columns -->
<!-- ## Some features are implemented but disabled by the graph network -->
<!-- ## No real ?eval expressions just some features (hard) evaluated -->
<!--   observeEvent(input[["visnet_graphChange"]],{ -->
<!--     # If the user added a node, add it to the data frame of nodes. -->
<!--     if(input[["visnet_graphChange"]][["cmd"]] == "addNode") { -->
<!--       temp = bind_rows( -->
<!--         graph_data$nodes, -->
<!--         data.frame(id = input[["visnet_graphChange"]]$id, -->
<!--                    label = input[["visnet_graphChange"]]$label, -->
<!--                    stringsAsFactors = F) -->
<!--       ) -->
<!--       graph_data$nodes = temp -->
<!--     } -->
<!--     # If the user added an edge, add it to the data frame of edges. -->
<!--     else if(input[["visnet_graphChange"]]$cmd == "addEdge") { -->
<!--       tmp = bind_rows( -->
<!--         graph_data$edges, -->
<!--         data.frame(id=(nrow(graph_data$edges)+1) , -->
<!--                    from =input[["visnet_graphChange"]]$from, -->
<!--                    to = input[["visnet_graphChange"]]$to, -->
<!--                    stringsAsFactors = F) -->
<!--       ) -->
<!--       ## if eeg changed -->
<!--       if(length(findexg(graph_data$nodes,graph_data$edges,1))!= -->
<!--          length(findexg(graph_data$nodes,tmp,1))){ -->
<!--         ## to and from cases -->
<!--         if(as.character(input[["visnet_graphChange"]]$to) %in% -->
<!--            as.character(subset(graph_data$nodes,group=="physical")$id)){ -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label[ -->
<!--               as.character(subset(graph_data$nodes,group=="physical")$id) %in% -->
<!--               as.character(input[["visnet_graphChange"]]$to )]) -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]*(1000*1000) -->
<!--             ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000*1000) -->
<!--           }else{ -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc. -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label[ -->
<!--               as.character(subset(graph_data$nodes,group=="physical")$id) %in% -->
<!--               as.character(input[["visnet_graphChange"]]$from )]) -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]*(1000*1000) -->
<!--             ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000*1000) -->
<!--              } -->
<!--       } -->
<!--       if(length(findexg(graph_data$nodes,graph_data$edges,2))!= -->
<!--          length(findexg(graph_data$nodes,tmp,2))| -->
<!--          length(findexg(graph_data$nodes,graph_data$edges,3))!= -->
<!--          length(findexg(graph_data$nodes,tmp,3))| -->
<!--          length(findexg(graph_data$nodes,graph_data$edges,4))!= -->
<!--          length(findexg(graph_data$nodes,tmp,4))){ -->
<!--           if(as.character(input[["visnet_graphChange"]]$to) %in% -->
<!--              as.character(subset(graph_data$nodes,group=="physical")$id)){ -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label[ -->
<!--               as.character(subset(graph_data$nodes,group=="physical")$id) %in% -->
<!--               as.character(input[["visnet_graphChange"]]$to) ]) -->
<!--             ## convert all data to uV range - now only timeseries, but also filters, disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]*1000 -->
<!--             ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*1000 -->
<!--           }else{ -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label[ -->
<!--               as.character(subset(graph_data$nodes,group=="physical")$id) %in% -->
<!--               as.character(input[["visnet_graphChange"]]$from )]) -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]*(1000) -->
<!--             ExG$freq[,paste0("Filtered",chan)]=ExG$freq[,paste0("Filtered",chan)]*(1000) -->
<!--              } -->
<!--          } -->

<!--       graph_data$edges = tmp -->
<!--     } -->
<!--     # If the user edited a node, update that record. -->
<!--     else if(input[["visnet_graphChange"]]$cmd == "editNode") { -->
<!--       temp = graph_data$nodes -->
<!--       temp$label[as.character(temp$id) == as.character(input[["visnet_graphChange"]]$id)] = as.character(input[["visnet_graphChange"]]$label) -->
<!--       graph_data$nodes = temp -->
<!--       physigs=as.character(subset(graph_data$nodes,group=="physical")$label) -->
<!--       colnames(ExG$ts)=physigs -->
<!--       colnames(ExG$freq)=paste0("Filtered",physigs) -->

<!--     } -->
<!--     # If the user edited an edge, update that record. -->
<!--     else if(input[["visnet_graphChange"]]$cmd == "editEdge") { -->
<!--       temp = graph_data$edges -->
<!--       temp$from[temp$id == input[["visnet_graphChange"]]$id] = input[["visnet_graphChange"]]$from -->
<!--       temp$to[temp$id == input[["visnet_graphChange"]]$id] = input[["visnet_graphChange"]]$to -->
<!--       graph_data$edges = temp -->
<!--     } -->
<!--     # If the user deleted something, remove those records. -->
<!--     if(input[["visnet_graphChange"]]$cmd == "deleteElements") { -->
<!--       globtmp=graph_data$nodes -->
<!--       for(node.id in input[["visnet_graphChange"]]$nodes) { -->
<!--         tmp = globtmp -->
<!--         tmp = tmp[tmp$id != node.id,] -->
<!--         globtmp = tmp -->
<!--       } -->
<!--       graph_data$nodes=globtmp -->
<!--       globtmp=graph_data$edges -->
<!--       for(edge.id in input[["visnet_graphChange"]]$edges) { -->
<!--         tmp = globtmp -->
<!--         tmp = tmp[tmp$id != edge.id,] -->

<!--         globtmp = tmp -->
<!--       } -->
<!--       tmp=globtmp -->
<!--       if(length(findexg(graph_data$nodes,graph_data$edges,1))!= -->
<!--          length(findexg(graph_data$nodes,tmp,1))){ -->
<!--       for(i in input[["visnet_graphChange"]]$edges){ -->
<!--           if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"]) %in% -->
<!--              as.character(subset(graph_data$nodes,group=="physical")$id)){ -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"])] -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]/(1000*1000) -->
<!--             # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan] -->
<!--           } -->
<!--           if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"]) %in% -->
<!--              as.character(subset(graph_data$nodes,group=="physical")$id)){ -->
<!--             ## convert all data to uV range - now only timeseries, but also filters, disp, etc. -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"])] -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]/(1000*1000) -->
<!--             # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan] -->
<!--           } -->
<!--       } -->
<!--       } -->
<!--       if(length(findexg(graph_data$nodes,graph_data$edges,2))!= -->
<!--          length(findexg(graph_data$nodes,tmp,2))| -->
<!--          length(findexg(graph_data$nodes,graph_data$edges,3))!= -->
<!--          length(findexg(graph_data$nodes,tmp,3))| -->
<!--          length(findexg(graph_data$nodes,graph_data$edges,4))!= -->
<!--          length(findexg(graph_data$nodes,tmp,4))){ -->
<!--         for(i in input[["visnet_graphChange"]]$edges){ -->
<!--           if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"]) %in% -->
<!--              as.character(subset(graph_data$nodes,group=="physical")$id)){ -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"from"])] -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]/(1000) -->
<!--             # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan] -->
<!--           } -->
<!--           if(as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"]) %in% -->
<!--              as.character(subset(graph_data$nodes,group=="physical")$id)){ -->
<!--             ## convert all data to uV range - now only timeseries, but also filters, disp, etc. -->
<!--             chan=as.character(subset(graph_data$nodes,group=="physical")$label)[as.character(subset(graph_data$nodes,group=="physical")$id) %in% as.character(graph_data$edges[graph_data$edges[,"id"]==i,"to"])] -->
<!--             ## convert all data to uV/mV range - now only timeseries and filters, but also disp, etc. -->
<!--             ExG$ts[,chan]=ExG$ts[,chan]/(1000) -->
<!--             # ExG$freq[,paste0("Filtered",chan)]=ExG$ts[,chan] -->
<!--           } -->
<!--         } -->
<!--       } -->
<!--       graph_data$edges=tmp -->
<!--     } -->
<!--       graph_data$EEG=findexg(graph_data$nodes,graph_data$edges,1) -->
<!--       graph_data$ECG=findexg(graph_data$nodes,graph_data$edges,2) -->
<!--       graph_data$EOG=findexg(graph_data$nodes,graph_data$edges,3) -->
<!--       graph_data$EMG=findexg(graph_data$nodes,graph_data$edges,4) -->
<!-- }) -->
<!-- } -->

<!-- # renderPrint(print(visGetSelectedNodes(""))) -->
<!--   # observeEvent(input$current_node_id, { -->
<!--   #   visNetworkProxy("network_proxy") %>% -->
<!--   #     visGetNodes() -->
<!--   # }) -->

<!-- # observeEvent(input$visnet_selected,{ -->
<!-- #   if(any(input$visnet_selected %in% graph_data$nodes[graph_data$nodes$group %in% "Cluster","id"])){ -->
<!-- # -->
<!-- #     selicks=subset(graph_data$nodes,group=="Cluster")[graph_data$nodes[graph_data$nodes$group %in% "Cluster","id"] %in% input$visnet_selected,] -->
<!-- # -->
<!-- #     update_nodes_components() -->
<!-- # -->
<!-- #   } -->
<!-- # -->
<!-- # }) -->


<!-- ``` -->


<!-- ```{r,filter_apply} -->

<!-- if(shiny_running()){ -->
<!-- observeEvent(input$filter_button, -->
<!--              { -->
<!--     if(!is.null(input$visnet_selected)&any(input$visnet_selected %in% biosigs$id)){ -->
<!--       vis_sub=input$visnet_selected[input$visnet_selected %in% biosigs$id] -->

<!--       chans=graph_data$nodes$id %in% input$visnet_selected -->

<!--       filt_ch=as.character(graph_data$nodes[chans,"label"]) -->

<!--       # if notch filtered, create new edge signal to filter -->
<!--       if(input$stoppoint!=0){ -->
<!--         graph_data$edges=bind_rows(graph_data$edges, -->
<!--           data.frame(label=(nrow(graph_data$edges)+1): -->
<!--                            (nrow(graph_data$edges)+ -->
<!--                               length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])), -->
<!--                  from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch], -->
<!--                  to=graph_data$nodes$id[graph_data$nodes$label %in% "Notch"], -->
<!--           title=paste0("<p>Notch:", input$stoppoint,"</p>"), -->
<!--           value=1,stringsAsFactors = F)) -->
<!--       } -->
<!--       ## same for passband -->
<!--       if(any(input$passband!=c(0,250))){ -->
<!--         graph_data$edges=bind_rows(graph_data$edges, -->
<!--           data.frame(label=(nrow(graph_data$edges)+1): -->
<!--                            (nrow(graph_data$edges)+ -->
<!--                               length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])), -->
<!--                  from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch], -->
<!--                  to=graph_data$nodes$id[graph_data$nodes$label %in% "Low Pass"], -->
<!--           title=paste0("<p>Low Pass:", input$passband[1],"</p>"), -->
<!--           value=(input$passband[2]-input$passband[1])/(ExG$srate/2),stringsAsFactors = F)) -->
<!--         graph_data$edges=bind_rows(graph_data$edges, -->
<!--           data.frame(label=(nrow(graph_data$edges)+1): -->
<!--                            (nrow(graph_data$edges)+ -->
<!--                               length(graph_data$nodes$id[graph_data$nodes$label %in% filt_ch])), -->
<!--                  from=graph_data$nodes$id[graph_data$nodes$label %in% filt_ch], -->
<!--                  to=graph_data$nodes$id[graph_data$nodes$label %in% "High Pass"], -->
<!--           title=paste0("<p>High Pass:", input$passband[2],"</p>"), -->
<!--           value=(input$passband[2]-input$passband[1])/(ExG$srate/2),stringsAsFactors = F)) -->
<!--       } -->
<!--       ## apply filter -->

<!--       tmp=freq_filter(ExG$ts[,graph_data[[filt_ch]]],ExG$srate, -->
<!--                       as.numeric(as.character(input$stoppoint)), -->
<!--                       input$passband,graph_data[[filt_ch]]) -->

<!--       colnames(tmp)<-paste0("Filtered",colnames(tmp)) -->
<!--       ExG$freq[,(colnames(ExG$freq) %in% paste0("Filtered",graph_data[[filt_ch]]))]=tmp -->


<!--       # tmp2=ExG$freq[,!(colnames(ExG$freq) %in% paste0("Filtered",graph_data[filt_ch]))] -->
<!--       # ExG$freq<-as.xts(tmp[,(colnames(tmp) %in% paste0("Filtered",graph_data[filt_ch]))], -->
<!--       #              seq(Disp$posix, by=1/ExG$srate,length=nrow(tmp))) -->
<!--       # ExG$freq=cbind(ExG$freq,tmp2) -->
<!--       # ExG$freq[,order()] -->

<!--       ## Change width of edge -->
<!--       # graph_data$edges -->
<!--     } -->

<!-- }) -->
<!-- } -->
<!-- ``` -->



<!-- *** -->

<!-- ```{r, filter_ui} -->
<!-- if(shiny_running()){ -->
<!--   selectInput("stoppoint", label = "Select (Notch) Frequency to silence:", -->
<!--               choices = c(0, 50, 60), selected = 0) -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!--   renderUI({sliderTextInput( -->
<!--    inputId = "passband", -->
<!--    label = "Select Band to pass:", -->
<!--     choices = c(seq(0.1,10,by=0.1),seq(10,round(ExG$srate/2,0))), -->
<!-- selected = c(2, 30), -->
<!--    from_min = 0.1, -->
<!--     from_max = 10, -->
<!--    to_min = 30, -->
<!--    to_max = 100, -->
<!--    grid = TRUE -->
<!-- )}) -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!--   plotOutput("freq_band",click = "click_plot") -->
<!-- } -->

<!-- # renderPrint( { -->
<!-- #     if (!is.null(input$current_node_id) && !is.null(input$visnet_nodes)) { -->
<!-- #       print(input$current_node_id) -->
<!-- #       # info <- data.frame(matrix(unlist(), -->
<!-- #       #                           ncol = dim(nodes)[1], byrow = T), -->
<!-- #       #                    stringsAsFactors = FALSE) -->
<!-- #       # colnames(info) <- colnames(nodes) -->
<!-- #       # info[info$id == input$current_node_id, ] -->
<!-- #     } -->
<!-- #   }) -->


<!-- # renderPrint(print(visNetworkProxy("visnet")%>%visGetSelectedNodes())) -->
<!-- # -->
<!-- # if(shiny_running()){ -->
<!-- #   renderUI({ -->
<!-- #   spindle_choices=c(colnames(ExG$freq),paste0("Clust",names(ExG$gssa))) -->
<!-- # -->
<!-- #   pickerInput( -->
<!-- #     inputId = "", -->
<!-- #     label = "Select Channels/Sources for Spindle Detection", -->
<!-- #     choices =spindle_choices, -->
<!-- #     options = list( -->
<!-- #     `actions-box` = TRUE, -->
<!-- #     size = 10 -->
<!-- #   ), -->
<!-- #   multiple = F -->
<!-- #   ) -->
<!-- #   }) -->
<!-- # } -->



<!-- if(shiny_running()){ -->
<!--   actionButton("filter_button", "Apply Filter / Bandpower") -->
<!-- } -->



<!-- ``` -->

<!-- ```{r} -->

<!-- # renderPrint(print(c(filter_value(graph_data$nodes,graph_data$edges,s="EEG"),filter_value(graph_data$nodes,graph_data$edges,s="ECG"),filter_value(graph_data$nodes,graph_data$edges,s="EOG"),filter_value(graph_data$nodes,graph_data$edges,s="EMG")))) -->
<!-- if(shiny_running()){ -->
<!--   textInput("pat_desc", "Patient Description", -->
<!--               value = "John Doe, M, 25, Apnoe, no Medication", placeholder = "Name of Patient") -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!--   downloadButtonRmd("downloadEDF", "Download EDF") -->
<!-- } -->

<!-- # observeEvent(input$edf_create,{ -->
<!-- #   showModal(modalDialog( -->
<!-- #   , -->
<!-- # -->
<!-- #       ) -->
<!-- #     ) -->
<!-- # }) -->

<!-- ``` -->


<!-- ```{r,edfoutput,echo=F} -->

<!-- if(shiny_running() ){ -->
<!-- output$downloadEDF <- downloadHandler( -->
<!--   filename = function(){paste0(input$pat_desc,"_",format(as.Date(Disp$posix),format="%d.%m.%y"),".edf")}, -->
<!--   content = function(file){ -->
<!--     edf_dat=ExG$freq[,paste0("Filtered",c(graph_data$EEG,graph_data$ECG,graph_data$EOG,graph_data$EMG))] -->
<!--     # edf_dat[,paste0("Filtered",graph_data$EEG)]=round(edf_dat[,paste0("Filtered",graph_data$EEG)],0) -->
<!--     # edf_dat[,paste0("Filtered",c(graph_data$ECG,graph_data$EOG,graph_data$EMG))]= -->
<!--     #   round(edf_dat[,paste0("Filtered",c(graph_data$ECG,graph_data$EOG,graph_data$EMG))]/1000,3) -->
<!--     unitz=c(rep("uV",length(graph_data$EEG)),rep("mV",length(c(graph_data$ECG,graph_data$EOG,graph_data$EMG)))) -->
<!--     ##Transform unit according to Signal -->
<!--     # scaleExGsig<-function(df,eegs,ecgs,eogs,emgs){ -->
<!--     #   df[,paste0("Filtered",eegs)]<-df[,paste0("Filtered",eegs)]*1000000 -->
<!--     #   df[,paste0("Filtered",c(ecgs,eogs,emgs))]<-df[,paste0("Filtered",c(ecgs,eogs,emgs))]*1000 -->
<!--     #   return(df) -->
<!--     # } -->
<!--     # edf_dat=scaleExGsig(edf_dat,graph_data$EEG,graph_data$ECG,graph_data$EOG,graph_data$EMG) -->

<!--     ## Could be better from source relation naming -->
<!--     snames=c(paste0("EEG",graph_data$EEG), -->
<!--              paste0("ECG",graph_data$ECG), -->
<!--              paste0("EOG",graph_data$EOG), -->
<!--              paste0("EMG",graph_data$EMG)) -->

<!--     # prefilterings=c(rep(paste0("N:",input$stoppoint,"Hz L:",input$passband[1],"Hz H:",input$passband[2],"Hz"), -->
<!--     #                     length(graph_data$EEG)), -->
<!--     #                 rep(paste0("N:",0,"Hz L:",0,"Hz H:",2*ExG$srate,"Hz"), -->
<!--     #                     length(c(graph_data$ECG,graph_data$EOG,graph_data$EMG)))) -->

<!--     prefilterings=c(filter_value(graph_data$nodes,graph_data$edges,s="EEG"),filter_value(graph_data$nodes,graph_data$edges,s="ECG"),filter_value(graph_data$nodes,graph_data$edges,s="EOG"),filter_value(graph_data$nodes,graph_data$edges,s="EMG")) -->
<!--     srs=rep(ExG$srate,ncol(edf_dat)) -->

<!--     recId="None" -->
<!--     patId=input$pat_desc -->
<!--     startdate=format(as.Date(Disp$posix),format="%d.%m.%y") -->
<!--     starttime=strftime(Disp$posix,format = "%H.%M.%S") -->
<!--     fn=paste0(mainDir,"/",input$pat_desc,"_",startdate,".edf") -->
<!-- signals=edf_dat -->

<!--   if(file.exists(fn)) {file.create(fn,overwrite=T) -->
<!--     }else{file.create(fn,overwrite=F)} -->
<!--   fid<-file(fn,'wb') -->
<!--   numSignals <- length(srs) -->

<!--   ## Mentalab Rounding -->
<!--   # signals=round(signals,2) -->

<!--   # Calculate recording length (in seconds) -->
<!--   recLength <- (-1) -->
<!--   for (k in 1:numSignals){ -->
<!--     recLength <- max(recLength, length(signals[,k])/srs[k]) -->
<!--   } -->
<!--   recLength <- ceiling(recLength)# Ceil to an integer number -->

<!--   # Asuming 1s databloack duration. Check possible incompatibilities -->
<!--   blockSizeBytes <- sum(2*srs) -->

<!--   if(blockSizeBytes > 61440){ -->
<!--     print('Yet to be implemented: Signals cannot fit on a 1s datablock. Check for (other block size possibilities)') -->
<!--   } else { -->
<!--     blockSize <- 1 -->
<!--     numBlocks <- recLength -->
<!--   } -->

<!--   general_header_size <- 256#bytes -->
<!--   one_signal_header_size <- 256#bytes -->

<!--   # Write edf -->

<!--   # FIXED HEADER -->
<!--   header.version <- 0 -->
<!--   header.local_patient_identification <- patId -->
<!--   header.local_recording_identification <- recId -->
<!--   header.startdate_recording <- startdate -->
<!--   header.starttime_recording <- starttime -->
<!--   header.num_signals <- numSignals -->
<!--   header.num_bytes_header <- general_header_size + one_signal_header_size * numSignals -->
<!--   header.reserved <- '' -->
<!--   header.duration_data_record <- blockSize -->
<!--   header.num_data_records <- numBlocks -->

<!--   trimAndFillWithBlanks<-function(txt, maxLength, justify='left'){ -->
<!--     # if(nargin == 2)justify = 'left' -->
<!--     if(nchar(txt) > maxLength){result = substr(txt,1,maxLength) -->
<!--     }else{ -->
<!--       if(justify== 'right'){ -->
<!--         result<-paste0(paste0(rep(" ",(maxLength-length(txt))),collapse=""),txt)} -->
<!--       else{ -->
<!--         result<-paste0(txt,paste0(rep(" ",(maxLength-nchar(txt))),collapse="")) -->
<!--       } -->
<!--     } -->
<!--     return(result) -->
<!--   } -->

<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.version,8)),fid,endian = "little")# version -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.local_patient_identification,80)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.local_recording_identification,80)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.startdate_recording,8)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.starttime_recording,8)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.num_bytes_header,8)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.reserved,44)),fid,endian="little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.num_data_records,8)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.duration_data_record,8)),fid,endian = "little") -->
<!--   writeBin(charToRaw(trimAndFillWithBlanks(header.num_signals,4)),fid,endian = "little") -->

<!--   # SIGNAL DEPENDENT HEADER -->
<!--   signalOffsets <- rep(0, numSignals)# In bytes -->
<!--   header.signals_info=data.frame(label=rep("",numSignals), -->
<!--                                  transducer_type=rep("",numSignals), -->
<!--                                  physical_dimension=rep("",numSignals), -->
<!--                                  physical_min=rep("",numSignals), -->
<!--                                  physical_max=rep("",numSignals), -->
<!--                                  digital_min=rep("",numSignals), -->
<!--                                  digital_max=rep("",numSignals), -->
<!--                                  prefiltering=rep("",numSignals), -->
<!--                                  num_samples_datarecord=rep("",numSignals), -->
<!--                                  reserved=rep("",numSignals), -->
<!--                                  sample_rate=rep("",numSignals), -->
<!--                                  signalOffset=rep("",numSignals),stringsAsFactors = F) -->

<!--   # for(i in 1:ncol(header.signals_info)){ -->
<!--   #   header.signals_info[colnames(header.signals_info)[i]]<-as.character(header.signals_info[colnames(header.signals_info)[i]]) -->
<!--   # } -->

<!--   #Mentalab values -->
<!--   Pmins<-floor(unlist(lapply(signals,min))) -->
<!--   # Pmins<-floor(unlist(lapply(signals,max))[seq(2, ncol(signals)*5, 5)]) -->
<!--   Pmaxs<-ceiling(unlist(lapply(signals,max))) -->
<!--   # Pmaxs<-ceiling(unlist(lapply(signals,quantile))[seq(4, ncol(signals)*5, 5)]) -->
<!--   Dmins<-rep(-32768,numSignals) -->
<!--   Dmaxs<-rep(32767,numSignals) -->

<!--   if( (  log(    (max(abs(Dmins))+max(abs(Dmaxs))+1) ,2  ) / (max(abs(Pmins))+max(abs(Pmaxs)))    )  > 16 ){ print("Error, Accucracy to high, not 16 bit, either shrink distance !Dmin to Dmax!, or Pmin to Pmax")} -->

<!--   for (k in 1:numSignals){ -->
<!--     header.signals_info[k,"label"] <- snames[k] -->
<!--     header.signals_info[k,"transducer_type"] <- '' -->
<!--     header.signals_info[k,"physical_dimension"] <- unitz[k] -->

<!--     header.signals_info[k,"physical_min"] <- Pmins[k] -->
<!--     header.signals_info[k,"physical_max"] <- Pmaxs[k] -->
<!--     header.signals_info[k,"digital_min"] <- Dmins[k] -->
<!--     header.signals_info[k,"digital_max"] <- Dmaxs[k] -->

<!--     header.signals_info[k,"prefiltering"] <- prefilterings[k] -->
<!--     header.signals_info[k,"num_samples_datarecord"] <- as.character(as.numeric(srs[k])*as.numeric(blockSize)) -->
<!--     header.signals_info[k,"reserved"] <- '' -->
<!--     # NOTE: The two following are not specific EDF header fields, but are practical for EDF handling -->
<!--     header.signals_info[k,"sample_rate"] <- as.character(as.numeric(header.signals_info[k,"num_samples_datarecord"])/ -->
<!--       as.numeric(header.duration_data_record)) -->
<!--     if (k > 1){ -->
<!--       signalOffsets[k] <- signalOffsets[k - 1] + 2 * as.numeric(header.signals_info[k - 1,"num_samples_datarecord"]) -->
<!--     } -->
<!--     header.signals_info[k,"signalOffset"] <- signalOffsets[k] -->
<!--   } -->

<!--   # Write signal-dependent header to file -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"label"],16)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"transducer_type"],80)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"physical_dimension"],8)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"physical_min"]),8)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"physical_max"]),8)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"digital_min"]),8)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"digital_max"]),8)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"prefiltering"],80)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(as.character(header.signals_info[k,"num_samples_datarecord"]),8)),fid,endian="little") -->
<!--   } -->
<!--   for (k in 1:numSignals){ -->
<!--     writeBin(charToRaw(trimAndFillWithBlanks(header.signals_info[k,"reserved"],32)),fid,endian="little") -->
<!--   } -->

<!--   # Check data starting point -->
<!--   current_position <-seek(fid)# in bytes -->
<!--   if (header.num_bytes_header!= current_position){ -->
<!--     print('Something wrong could be happening: unexpected position at the beginning of the first data block') -->
<!--   } -->
<!--   bytes_full_data_record <- 2 * sum(as.numeric(unlist(header.signals_info["num_samples_datarecord"]))) -->

<!--   # DATA WRITING -->


<!--   close(fid) -->

<!--   for (k in 1:numBlocks){ -->
<!--     printmes=F -->
<!--     if((k %% 100)==0 & printmes==T)ExG$a=k -->
<!--     # Initialize datablock -->
<!--     data <- rep(0, bytes_full_data_record/2)# Num samples per data record -->

<!--     for (k1 in 1:numSignals){ -->
<!--       offsetSignal <- (k - 1) * as.numeric(header.signals_info[k1,"num_samples_datarecord"]) + 1 -->
<!--       onsetSignal <- min(offsetSignal + as.numeric(header.signals_info[k1,"num_samples_datarecord"]) - 1, -->
<!--                          length(signals[,k1])) -->
<!--       offsetDataBlock <- as.numeric(header.signals_info[k1,"signalOffset"])/2 + 1 -->
<!--       onsetDataBlock <- offsetDataBlock +  onsetSignal-offsetSignal -->
<!--       data[offsetDataBlock:onsetDataBlock] <- as.integer(Dmins[k1] + (Dmaxs[k1] - Dmins[k1]) * -->
<!--                                                            ((signals[offsetSignal:onsetSignal,k1] - Pmins[k1])/(Pmaxs[k1] - Pmins[k1]))) -->
<!--     } -->
<!--     if(max(int_to_unit(data))>65536)print("Error") -->
<!--     py$writeEDFbin(fn,data) -->
<!--   } -->


<!--     file.rename(fn, file) -->
<!--   } -->
<!-- ) -->
<!-- } -->



<!-- ``` -->



<!-- ### Sleep Spindles and QRS Detection -->

<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!-- fillCol(renderTable({res=as.data.frame(ExG$hrv[[2]]["TimeAnalysis"]) -->
<!-- colnames(res)=unlist(lapply(strsplit(colnames(res),"TimeAnalysis."),function(x)x[[2]])) -->
<!-- round(res,0)}), -->
<!-- fillRow( -->
<!-- renderPlot({PlotSinglePowerBand(ExG$hrv[[1]], 1, "LF/HF",doPlot=T,main="heart related stress adaption",                     eplim=c(min(ExG$hrv[[1]]$FreqAnalysis[[1]]$LFHF),max(ExG$hrv[[1]]$FreqAnalysis[[1]]$LFHF)))}), -->

<!-- renderPlot({PoincarePlot(ExG$hrv[[3]],indexNonLinearAnalysis=1,timeLag=1, doPlot=T)})),flex=c(1,5)) -->
<!-- }else{ -->
<!--   # kable(as.data.frame(EXG$hrv[[2]]["TimeAnalysis"])) -->
<!--   # PlotSinglePowerBand(EXG$hrv[[1]], 1, "LF/HF",doPlot=T,main="heart related stress adaption",                     eplim=c(min(EXG$hrv[[1]]$FreqAnalysis[[1]]$LFHF),max(EXG$hrv[[1]]$FreqAnalysis[[1]]$LFHF))) -->
<!--   # PoincarePlot(EXG$hrv[[3]],indexNonLinearAnalysis=1,timeLag=1, doPlot=T) -->
<!-- } -->
<!-- ``` -->


<!-- *** -->


<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!--   renderPrint(print(min(last(index(Disp$orig.disp)),Disp$resol[2]))) -->
<!-- } -->
<!-- if(shiny_running()){ -->
<!--   renderPrint(print(max(first(index(Disp$orig.disp)),Disp$resol[1]))) -->
<!-- } -->
<!-- if(shiny_running()){ -->
<!--   renderPrint(head(ExG$disp)) -->
<!-- } -->
<!-- if(shiny_running()){ -->
<!--   renderPrint(print(input$ecg_ana)) -->
<!-- } -->
<!-- if(shiny_running()){ -->
<!--   renderPrint(Disp$newfile) -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!--   sliderInput("L", label = "Window Length", min = 10,max = 50, value = 30,step=1) -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!--   renderUI({ -->
<!--   eeg_choicings=c(graph_data$EEG) -->
<!--   pickerInput( -->
<!--     inputId = "eeg_ana", -->
<!--     label = "Select Channel for Sleep Spindles & Baandpower", -->
<!--     choices =c(eeg_choicings), -->
<!--     options = list(title = "Channels",`actions-box` = TRUE,size = 10), -->
<!--   multiple = F -->
<!--   ) -->
<!--   }) -->
<!-- } -->

<!-- if(shiny_running()){ -->
<!--   renderUI({ -->
<!--     ecg_choicings=c(graph_data$ECG) -->
<!--   pickerInput( -->
<!--     inputId = "ecg_ana", -->
<!--     label = "Select Channel for QRS Detection", -->
<!--     choices =ecg_choicings, -->
<!--     options = list(title = "Channels",`actions-box` = TRUE,size = 10), -->
<!--   multiple = F -->
<!--   ) -->
<!--   }) -->
<!-- } -->
<!-- if(shiny_running()){ -->
<!--   actionButton("ana_button", label = "Analyze") -->
<!-- } -->

<!-- ``` -->


<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!--   observeEvent(input$ana_button,{ -->
<!--   if(input$ecg_ana!=""){ -->
<!--     res=py$qrs_detect(coredata(ExG$ts)[,input$ecg_ana],ExG$srate) -->
<!--     ExG$qrs=data.frame(rep("QRS",length(res)),first(index(ExG$ts))+res) -->
<!--     ExG$hrv=hrv_analysis(res,ExG$srate,mainDir) -->
<!--   } -->
<!--   if(input$eeg_ana!=""){ -->
<!--     tmp_bp=rel_bp(coredata(ExG$freq)[,paste0("Filtered",input$eeg_ana)]) -->
<!--     ExG$bandpower=as.xts((tmp_bp[,1:5]/tmp_bp[,6])*100,seq(Disp$posix, by=input$L, length=nrow(tmp_bp))) -->
<!--     ExG$spindles=data.frame() -->
<!--   for(i in 1:(nrow(ExG$stages))){ -->
<!--   ## Limit stages -->
<!--   if(i!=nrow(ExG$stages)){tmp=window(ExG$freq,start=ExG$stages[i,2],end=ExG$stages[i+1,2]) -->
<!--   }else{tmp=window(ExG$freq,start=ExG$stages[i,2],end=last(index(ExG$freq)))} -->
<!--   res<-data.frame( -->
<!--     py$sleep_spindles(tmp[,paste0("Filtered",input$eeg_ana)],ExG$srate), -->
<!--     stringsAsFactors = F)[,c("Start","Duration","Oscillations")] -->
<!--   ExG$spindles=rbind(ExG$spindles,data.frame(Start=ExG$stages[i,2]+res$Start,stringsAsFactors = F)) -->
<!--   } -->
<!--   ExG$spindles=setNames(  -->
<!--     data.frame(rep("Spindle",nrow(ExG$spindles)),ExG$spindles$Start,stringsAsFactors = F),c("Event","Time")) -->
<!--   } -->
<!-- }) -->
<!-- } -->

<!-- ``` -->


<!-- ### Singular Spectrum Analysis - Manual Clustering: Click on Component (red square) -> Click on Component in New Cluster -->

<!-- ```{r, staging table and SSA plot} -->
<!-- if(shiny_running()){ -->
<!--   output$stages<-renderDT({ -->
<!--     DT::datatable( -->
<!--       data.frame( -->
<!--         cbind( -->
<!--           ExG$stages[,1], -->
<!--           strftime(ExG$stages[,2],format="%H:%M:%S")), -->
<!--         stringsAsFactors = F), -->
<!--       editable=T,options = list(dom = 'pt'), -->
<!--       colnames = c("Stage","Time")) -->
<!--     }) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ### OBSERVER FOR EDITING -->
<!-- if(shiny_running()){ -->
<!--   #Editable stages -->
<!--   observeEvent(input[["stages_cell_edit"]],{ -->
<!--     tmp=input[["stages_cell_edit"]] -->
<!--     if(tmp$col==2){ -->
<!--       if(length(strsplit(tmp$value,":")[[1]])>=2){ -->
<!--         if(!to_day(Disp$posix,tmp$value)){ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix)+1,tmp$value)) -->
<!--         }else{ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix),tmp$value)) -->
<!--         } -->
<!--       } -->
<!--       if(length(strsplit(tmp$value,":")[[1]])==2){ -->
<!--         if(!to_day(Disp$posix,tmp$value)){ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix)+1,paste0(tmp$value,":00"))) -->
<!--         }else{ -->
<!--           ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix),paste0(tmp$value,":00"))) -->
<!--         } -->
<!--       } -->
<!--     } -->
<!--     else{ -->
<!--     ExG$stages[tmp$row,tmp$col]<-tmp$value -->
<!--     } -->
<!--     ExG$stages=ExG$stages[!(ExG$stages[,1] %in% c("")),] -->
<!--   }) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!-- output$telco<-renderPlot({ -->
<!-- if(!is.null(input$ssa_channel) & Disp$hold==0){ -->
<!--   ###################GRAPHIC FOR ONE STAGE WITH ALL COMPONENTS -->
<!-- #   if(length(input$stages_rows_selected)!=1){ -->
<!-- #     if(input$time_real==F){ -->
<!-- #   p= ggplot()+geom_line(data=ExG$df_res,aes(x=ind,y=Value))+ -->
<!-- #     geom_line(data=ExG$df_res,aes(x=ind,y=Value,group=Comp,color=Comp))+ -->
<!-- #     theme_classic()+facet_grid(rows = vars(Row),cols=vars(Column))+theme(legend.position = "none")+ -->
<!-- #     scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->
<!-- #   }else{ -->
<!-- #   p= ggplot()+geom_line(data=ExG$df_res2,aes(x=ind,y=Value))+ -->
<!-- #     geom_line(data=ExG$df_res2,aes(x=ind,y=Value,group=Real,color=Real))+ -->
<!-- #     theme_classic()+facet_grid(rows = vars(Row),cols=vars(Column))+theme(legend.position = "none")+ -->
<!-- #     scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->
<!-- #  -->
<!-- #     } -->
<!-- #   p -->
<!-- # }else{ -->
<!-- #####################GRAPHIC FOR MANY STAGE FOR EACH CLUSTER -->

<!--   if(input$time_real==F){ -->
<!--  # p=ggplot()+geom_line( -->
<!--  #        data=ExG$df_res[ExG$df_res$Column==input$stages_rows_selected,], -->
<!--  #        aes(x=ind,y=Value,group=Comp,color=Comp))+ -->
<!--  #        theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+ -->
<!--  #   geom_rect(data = ExG$df_res[ExG$df_res$Column==input$stages_rows_selected & ExG$df_res$Comp %in% ExG$pan[2],],  -->
<!--  #                          fill = NA, colour = "red", xmin = -Inf,xmax = Inf, -->
<!--  #            ymin = -Inf,ymax = Inf)+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+ -->
<!--  #      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->

<!--  p=ggplot()+geom_line( -->
<!--         data=ExG$df_res, -->
<!--         aes(x=ind,y=Value,group=Comp,color=Comp))+ -->
<!--         theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+ -->
<!--    geom_rect(data = ExG$df_res[ExG$df_res$Comp %in% ExG$pan[2],],  -->
<!--                           fill = NA, colour = "red", xmin = -Inf,xmax = Inf, -->
<!--             ymin = -Inf,ymax = Inf)+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+ -->
<!--       scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->

<!--     }else{ -->
<!--  # p=ggplot()+geom_line( -->
<!--  #        data=ExG$df_res2[ExG$df_res2$Column==input$stages_rows_selected,], -->
<!--  #        aes(x=ind,y=Value,group=Real,color=Real))+ -->
<!--  #        theme_classic()+facet_wrap(c(vars(Real),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+ -->
<!--  #      scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->
<!--  p=ggplot()+geom_line( -->
<!--         data=ExG$df_res2, -->
<!--         aes(x=ind,y=Value,group=Real,color=Real))+ -->
<!--         theme_classic()+facet_wrap(c(vars(Real),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+ -->
<!--       scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->

<!--     } -->
<!--     p -->
<!-- # } -->
<!-- } -->
<!-- }) -->

<!-- } -->
<!-- ### FOR PDF -->
<!-- # if(!shiny_running()){ -->
<!-- #   ggplot()+geom_line( -->
<!-- #         data=EXG$df_res, -->
<!-- #         aes(x=ind,y=Value,group=Comp,color=Comp))+ -->
<!-- #         theme_classic()+facet_wrap(c( vars(Comp),vars(Row)))+theme(axis.ticks.x=element_blank(),axis.ticks.y=element_blank(),legend.position = "none")+ -->
<!-- #       scale_y_continuous(name="",breaks=c(-0.15,0,0.15))+scale_x_continuous("Index") -->
<!-- # } -->

<!-- if(shiny_running()){ -->
<!--     fillRow( -->
<!--     #################STAGING TABLE FOR SELECTION -->
<!--     fillCol( -->
<!--       renderUI({ -->
<!--         ssas=graph_data$EEG -->
<!--         pickerInput( -->
<!--           inputId = "ssa_channel", -->
<!--           choices =ssas, -->
<!--           options = list(title = "Channels",`actions-box` = TRUE,size = 10), -->
<!--           multiple = T -->
<!--         ) -->
<!--       }), -->
<!--       # DTOutput("stages"),flex=c(1,5)), -->
<!--     # fillCol( -->
<!--        switchInput(inputId = "time_real", label = "timed Realization", value=F), -->
<!--       # renderUI({ -->
<!--       # if(!is.null(input$stages_rows_selected)){ -->
<!--       # if(input$stages_rows_selected==1){ -->
<!--       # ############################### UI ELEMENTS FOR SSA TO EACH STAGE OR -->
<!--       knobInput( -->
<!--         inputId = "neigs", -->
<!--         label = "Number of Components", -->
<!--         value = 20, -->
<!--         max = 50, -->
<!--         min=2, -->
<!--         displayPrevious = TRUE, -->
<!--         lineCap = "round", -->
<!--         fgColor = "#428BCA", -->
<!--         inputColor = "#428BCA", -->
<!--         immediate=F -->
<!--       ), -->
<!--       #     }else{ -->
<!--       #   -->
<!--       # } -->
<!--       # } -->
<!--       # }), -->
<!--       knobInput( -->
<!--         inputId = "nclust", -->
<!--         label = "Number of Clusters", -->
<!--         value = 3, -->
<!--         max = 20, -->
<!--         min=1, -->
<!--         displayPrevious = TRUE, -->
<!--         lineCap = "round", -->
<!--         fgColor = "#428BCA", -->
<!--         inputColor = "#428BCA", -->
<!--         immediate=F -->
<!--       ) -->

<!--       ,flex=c(1,1,3,3)), -->
<!--     ##########################GRAPHIC TO BE RENDERED -->
<!--     plotOutput("telco",click = "plot_click"),flex=c(1,8))} -->


<!-- ``` -->


<!-- ```{r, singular spectrum analysis} -->
<!-- ## NO GOOD GOGETTER: APPLY SSA WHEN YOU KNOW ON WHAT AND SPECIFIY YOUR RANK! -->
<!-- ## NO GOOD GOGETTER: APPLY SSA WHEN YOU KNOW ON WHAT AND SPECIFIY YOUR RANK! -->
<!-- if(shiny_running()){ -->
<!-- observeEvent(c(input$ssa_channel,input$stages_rows_selected,input$neigs),{ -->
<!--   Disp$hold=1 -->
<!-- #  if(!is.null(input$ssa_channel) & length(input$stages_rows_selected)==1){ -->
<!--   if(!is.null(input$ssa_channel)){ -->
<!--   ### 60 Minutes maximum -->
<!--   # if(ExG$stages[input$stages_rows_selected+1,2]-ExG$stages[input$stages_rows_selected,2]<60){ -->
<!--     # tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)], -->
<!--     #                       start=ExG$stages[input$stages_rows_selected,2], -->
<!--     #                       end=ExG$stages[input$stages_rows_selected+1,2]),25) -->
<!--     if(sum(ExG$stages[,1]=="W")==2){ -->
<!--       s=ExG$stages[(ExG$stages[,1]=="W"[1])+1,2] -->
<!--       e=ExG$stages[(ExG$stages[,1]=="W"[2]),2] -->
<!--       tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)],start=s,end=e),25) -->
<!--     }else{ -->
<!--       tmp=downsample(ExG$freq[,paste0("Filtered",input$ssa_channel)],25) -->
<!--     } -->
<!--     ExG$ssa=ssa.svd(tmp,30*10,1,input$neigs) -->

<!--     ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$nclust,input$neigs)) -->
<!--     ExG$rssa=recons(ExG$ssa,ExG$gssa) -->
<!--     #ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,] -->
<!--     ExG$df_res=data.frame() -->
<!--     for(i in 1:length(ExG$gssa)){ -->
<!--       df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1]))) -->
<!--       df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]] -->
<!--       df=gather(df,key="Comp",value = "Value",-ind) -->
<!--       df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),] -->
<!--       df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]]))) -->
<!--       df$Row=i -->
<!--       #df$Column=input$stages_rows_selected -->
<!--       ExG$df_res=rbind(ExG$df_res,df) -->
<!--       ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO! -->
<!--       df=data.frame("ind"=seq(1,length(ExG$ssa$V[,1]))) -->
<!--       df[,paste0("Real",ExG$gssa[[i]])]=ExG$ssa$V[,ExG$gssa[[i]]] -->
<!--       df=gather(df,key="Real",value = "Value",-ind) -->
<!--       df=df[df$Real %in% paste0("Real",unlist(ExG$gssa[[i]])),] -->
<!--       df$Real=factor(df$Real,levels = paste0("Real",unlist(ExG$gssa[[i]]))) -->
<!--       df$Row=i -->
<!-- #      df$Column=input$stages_rows_selected -->
<!--       df$Column=input$stages_rows_selected -->
<!--       ExG$df_res2=rbind(ExG$df_res2,df) -->
<!--     } -->
<!--   } -->
<!--   Disp$hold=0 -->
<!-- }) -->

<!-- observeEvent(input$plot_click,{ -->
<!--   Disp$hold=1 -->
<!--   if(!is.null(input$ssa_channel) & !is.null(ExG$ssa)){ -->
<!--   #get the energy pattern -->
<!--     if(ExG$pan==0){ -->
<!--       ExG$pan=c(input$plot_click$panelvar1,input$plot_click$panelvar2) -->
<!--     }else{ -->
<!--       ##### Delete Component from Group -->
<!--       ExG$gssa[[as.numeric(ExG$pan[1])]]= -->
<!--         ExG$gssa[[as.numeric(ExG$pan[1])]][ExG$gssa[[as.numeric(ExG$pan[1])]] -->
<!--                                            !=strsplit(ExG$pan[2],"Comp")[[1]][2]] -->
<!--       ##### Add Component to Cluster -->
<!--       ExG$gssa[[as.numeric(input$plot_click$panelvar1)]]= -->
<!--         sort(as.numeric(append( -->
<!--           ExG$gssa[[as.numeric(input$plot_click$panelvar1)]],strsplit(ExG$pan[2],"Comp")[[1]][2]))) -->
<!--     hlist=list() -->
<!--     for(i in 1:length(ExG$gssa)){ -->
<!--       hlist[[i]]=ExG$gssa[[i]] -->
<!--     } -->
<!--     ExG$gssa=hlist -->
<!--     ExG$rssa=recons(ExG$ssa,ExG$gssa) -->
<!--     #ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,] -->
<!--     ExG$df_res=data.frame() -->
<!--     for(i in 1:length(ExG$gssa)){ -->
<!--       df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1]))) -->
<!--       df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]] -->
<!--       df=gather(df,key="Comp",value = "Value",-ind) -->
<!--       df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),] -->
<!--       df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]]))) -->
<!--       df$Row=i -->
<!--       # df$Column=input$stages_rows_selected -->
<!--       ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO! -->
<!--       ExG$df_res=rbind(ExG$df_res,df) -->
<!--     } -->

<!--       ExG$pan=0 -->
<!--     } -->
<!--   } -->
<!--   Disp$hold=0  -->
<!-- }) -->

<!-- observeEvent(input$nclust,{ -->
<!--   Disp$hold=1 -->
<!--   if(!is.null(input$ssa_channel) & !is.null(ExG$ssa)){ -->
<!--   ### 60 Minutes maximum -->
<!--     ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$nclust,input$neigs)) -->
<!--     ExG$rssa=recons(ExG$ssa,ExG$gssa) -->
<!-- #    ExG$df_res=ExG$df_res[ExG$df_res$Column!=input$stages_rows_selected,] -->
<!--     ExG$df_res=data.frame() -->
<!--     for(i in 1:length(ExG$gssa)){ -->
<!--       df=data.frame("ind"=seq(1,length(ExG$ssa$U[,1]))) -->
<!--       df[,paste0("Comp",ExG$gssa[[i]])]=ExG$ssa$U[,ExG$gssa[[i]]] -->
<!--       df=gather(df,key="Comp",value = "Value",-ind) -->
<!--       df=df[df$Comp %in% paste0("Comp",unlist(ExG$gssa[[i]])),] -->
<!--       df$Comp=factor(df$Comp,levels = paste0("Comp",unlist(ExG$gssa[[i]]))) -->
<!--       df$Row=i -->
<!--       # df$Column=input$stages_rows_selected -->
<!--       ### THIS IS THE DATAFROM FOR THE BIGPLOTS ALSO! -->
<!--       ExG$df_res=rbind(ExG$df_res,df) -->
<!--     } -->
<!--     Disp$hold=0   -->
<!--     } -->
<!-- }) -->
<!-- } -->


<!-- ######### THE OLD SSA WORKFLOW -->
<!-- # observeEvent(input$neigs,{ -->
<!-- #   if(!is.null(input$ssa_channel) &!is.null(input$ssa_stages)){ -->
<!-- #     if(input$ssa_stages!="All Stages"){ -->
<!-- #   sels=strsplit(input$ssa_stages," ")[[1]][3] -->
<!-- #   # ExG$stages[,2] %in% sels -->
<!-- # -->
<!-- #   if(!to_day(Disp$posix,sels)){ -->
<!-- #     i=which(ExG$stages[,2]%in%as.POSIXct(paste(as.Date(Disp$posix)+1,sels))) -->
<!-- #   }else{ -->
<!-- #     i=which(ExG$stages[,2]%in%as.POSIXct(paste(as.Date(Disp$posix),sels))) -->
<!-- #   } -->
<!-- #   if(ExG$stages[i+1,2]-ExG$stages[i,2]<60){ -->
<!-- #   tmp=downsample(window(ExG$freq[,paste0("Filtered",input$ssa_channel)],start=ExG$stages[i,2],end=ExG$stages[i+1,2]),25) -->
<!-- #   ExG$ssa=ssa.svd(tmp,30*10,1,input$neigs) -->
<!-- #   #vis_pipe$nodes=update_nodes_components(vis_pipe$nodes,ExG$ssa) -->
<!-- #   } -->
<!-- #   }else{ -->
<!-- #     tmp=downsample(ExG$freq[,paste0("Filtered",input$ssa_channel)],250) -->
<!-- #     arte=min(30,input$neigs) -->
<!-- #     ExG$ssa=ssa.svd(tmp,30,1,arte) -->
<!-- #    # vis_pipe$nodes=update_nodes_components(vis_pipe$nodes,ExG$ssa) -->
<!-- #   } -->
<!-- #   } -->
<!-- #   ExG$gssa=grouping.ssa(ExG$ssa,g=1:input$neigs,nc=min(input$neigs,input$nclust)) -->
<!-- #   #vis_pipe$nodes=update_nodes_cluster(vis_pipe$nodes,ExG$gssa) -->
<!-- #   #vis_pipe$edges=update_edges_cluster(vis_pipe$nodes,vis_pipe$edges,ExG$gssa) -->
<!-- #   ExG$rssa=recons(ExG$ssa,ExG$gssa) -->
<!-- # }) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # if(shiny_running()){ -->
<!-- # #Editable stages -->
<!-- # observeEvent(input[["stages_cell_edit"]],{ -->
<!-- #   tmp=input[["stages_cell_edit"]] -->
<!-- #   if(tmp$col==2){ -->
<!-- #     if(length(strsplit(tmp$value,":")[[1]])>=2){ -->
<!-- #       if(!to_day(Disp$posix,tmp$value)){ -->
<!-- #         ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix)+1,tmp$value)) -->
<!-- #       }else{ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix),tmp$value))} -->
<!-- #     } -->
<!-- #     if(length(strsplit(tmp$value,":")[[1]])==2){ -->
<!-- #       if(!to_day(Disp$posix,tmp$value)){ -->
<!-- #         ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix)+1,paste0(tmp$value,":00"))) -->
<!-- #       }else{ExG$stages[tmp$row,tmp$col]=as.POSIXct(paste(as.Date(Disp$posix),paste0(tmp$value,":00")))} -->
<!-- #     } -->
<!-- #   }else{ExG$stages[tmp$row,tmp$col]<-tmp$value} -->
<!-- #   ExG$stages=ExG$stages[!(ExG$stages[,1] %in% c("")),] -->
<!-- # }) -->
<!-- # } -->
<!-- ``` -->

<!-- ### Data Viewer & PDF - data is downsampled based on window range (a) more than 30 minutes (b) between 30 minutes and 20 seconds (c) less than 20 seconds -->

<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!-- fillRow(DTOutput("stages"), -->
<!-- renderTable({ -->

<!--   res=round(unlist(lapply(ExG$freq,function(x)nrow(x)/(ExG$srate*60)))[1],0) -->

<!-- res=c("Total",res) -->

<!-- df=data.frame("Stage"=ExG$stages[,1], -->
<!--               "Duration"=c(as.numeric(difftime(c(ExG$stages[-1,2],last(index(ExG$freq))), -->
<!--                                                ExG$stages[,2],units = "mins")))) -->
<!-- res2=ddply(df,"Stage",function(x)sum(x[,2])) -->
<!-- res2$Stage=as.character(res2$Stage) -->
<!-- res2$V1=round(res2$V1,0) -->
<!-- df_res=rbind(setNames(res,colnames(res2)),res2) -->
<!-- res3=t(py$glob_bp(array(coredata(ExG$freq[,paste0("Filtered",input$eeg_ana)])),ExG$srate)) -->
<!-- res3=round(res3[1:6,]*100,1) -->
<!-- df_res=rbind(df_res,setNames(data.frame(names(res3),as.matrix(res3)),colnames(df_res))) -->
<!-- res4=nrow(ExG$spindles) -->
<!-- df_res=rbind(df_res,setNames(data.frame("Sleep Spindles",res4),colnames(df_res))) -->

<!-- res5=c("Explained Variance SSA",round(sum(contributions(ExG$ssa)*100),1)) -->
<!-- ExG$summ=rbind(df_res,setNames(res5,colnames(df_res))) -->
<!-- ExG$summ -->
<!-- })) -->
<!-- }else{ -->
<!--   # kable(EXG$summ) -->
<!--   } -->
<!-- ``` -->


<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!-- observeEvent(input[["dygraph_click"]],{ -->
<!--   ## Add new row with inital Value Artifact to the EEG staging on click in graphic -->
<!--   ## Get the Date -->
<!--   if("Stages" %in% input$disp_event){ -->
<!--   date_click=strsplit(input[["dygraph_click"]][["x"]],"T")[[1]][1] -->
<!--   ## Get the Time, without the Z -->
<!--   time_click=strsplit(strsplit(input[["dygraph_click"]][["x"]],"T")[[1]][2],"Z")[[1]][1] -->
<!--   ## Adjust format and timezone -->
<!--   date_time_click=as.POSIXct(paste(date_click,time_click,format="%Y-%m-%d %H:%M:%OS"))+60*60 -->
<!--   ExG$stages= -->
<!--     data.frame(rbind(ExG$stages, -->
<!--           setNames(data.frame("A", -->
<!--                               date_time_click, -->
<!--                               stringsAsFactors = F), -->
<!--                    colnames(ExG$stages)))) -->
<!--   } -->
<!-- }) -->

<!-- observeEvent(input$downRater,{ -->
<!--   if(input$downRater!=0){ -->
<!--   downList=c("A","W","REM","S1","S2","S3") -->
<!--   if(any(ExG$stages[as.numeric(input$downRater),1] %in% downList)){ -->
<!--      if(ExG$stages[as.numeric(input$downRater),1]!="S3"){ -->
<!--      ExG$stages[as.numeric(input$downRater),1]= -->
<!--        downList[which(downList %in% ExG$stages[as.numeric(input$downRater),1] )+1] -->
<!--      ExG$stages=ExG$stages[order(ExG$stages[,2]),] -->
<!--      }else{ -->
<!--        ExG$stages=ExG$stages[-as.numeric(input$downRater),] -->
<!--        ExG$stages=ExG$stages[order(ExG$stages[,2]),] -->
<!--      } -->
<!--   } -->
<!--   } -->
<!-- }) -->

<!-- observeEvent(input$upRater,{ -->
<!--   if(input$upRater!=0){ -->
<!--   upList=c("S3","S2","S1","REM","W","A") -->
<!--   if(any(ExG$stages[as.numeric(input$upRater),1] %in% upList)){ -->
<!--     if(ExG$stages[as.numeric(input$upRater),1]!="A"){ -->
<!--       ExG$stages[as.numeric(input$upRater),1]= -->
<!--       upList[which(upList %in% ExG$stages[as.numeric(input$upRater),1] )+1] -->
<!--     }else{ -->
<!--       ExG$stages=ExG$stages[-as.numeric(input$upRater),] -->
<!--     } -->
<!--   } -->
<!--   } -->
<!-- }) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r} -->
<!-- ## interactive update window -->
<!-- if(shiny_running()){ -->
<!-- observeEvent({c(input[["dygraph_date_window"]], -->
<!--                 input$disp_chan, -->
<!--                input$disp_event, -->
<!--                input$disp_ssa)}, -->
<!--   { -->
<!--     if(!Disp$newfile){ -->
<!--   ##Check current display ranges range,timezone conversion etc. -->
<!--   r1=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[1]]),collapse = " "))+60*60 -->
<!--   r2=as.POSIXct(paste(as.character(strsplit(input[["dygraph_date_window"]],"T")[[2]]),collapse = " "))+60*60 -->
<!--   range=c(r1,r2) -->
<!--   d_range=difftime(range[2],range[1],units="secs") -->
<!--   resize=F -->
<!--   redat=F -->
<!--   ## Resolution changed? "bird" -hour, "time"-minute, "detail" -second -->
<!--   ## if so data need to be resampled resize=T -->
<!--   if(d_range<60 & Disp$sight!="detail"){ -->
<!--     resize=T -->
<!--     Disp$sight="detail" -->
<!--   } -->
<!--   if((d_range>=60 ) & Disp$sight!="time"){ -->
<!--     resize=T -->
<!--     Disp$sight="time" -->
<!--   } -->
<!--   # if((d_range>=60*30 & d_range<60*60*24) & Disp$sight!="bird"){ -->
<!--   #   resize=T -->
<!--   #   Disp$sight="bird" -->
<!--   # } -->

<!--   ## Select Channels to display - mutually exclusive for Source and Channel -->
<!--   if(!is.null(input$disp_chan)){ -->
<!--     ## Check for mutually exclusive groups - not working -->
<!--     if(!all(paste0("Filtered",input$disp_chan) %in% colnames(Disp$orig.chan))| -->
<!--        !all(colnames(Disp$orig.chan) %in% paste0("Filtered",input$disp_chan))){newdata=T}else{newdata=F} -->
<!--   }else{ -->
<!--     if(!is.null(colnames(Disp$orig.chan))){newdata=T}else{newdata=F} -->
<!--   } -->

<!--   #if anything is not displayed already -->
<!--   if(newdata){ -->
<!--     redat=T -->
<!--     tmp=xts(rep(NA,length(index(ExG$freq))),index(ExG$freq)) -->
<!--     colnames(tmp)="Empty" -->
<!--     if(!is.null(input$disp_chan)){ -->
<!--       for(i in 1:length(input$disp_chan)){ -->
<!--           tmp=merge(tmp,ExG$freq[,paste0("Filtered",input$disp_chan[i])]) -->
<!--       } -->
<!--     Disp$orig.chan=tmp[,colSums(is.na(tmp))<1000] -->
<!--     }else{ -->
<!--     Disp$orig.chan=tmp -->
<!--     } -->
<!--     # ExG$colors=c("#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#005a32")[ -->
<!--     #   colnames(ExG$freq) %in% sort(paste0("Filtered",input$disp_chan)) -->
<!--     # ] -->
<!--   } -->
<!--   newclust=(!all(input$disp_ssa %in% colnames(Disp$orig.ssa)))| -->
<!--     (!all(colnames(Disp$orig.ssa) %in% input$disp_ssa)) -->
<!--   if(redat|newclust){ -->
<!--     redat=T -->
<!--     tmp=Disp$orig.chan -->
<!--     # if(input$clust_disp){ -->
<!--       # ExG$rssa<-recons(ExG$ssa,ExG$gssa,stacked = F) -->
<!--     # }else{ -->
<!--     #   ExG$rssa<-recons(ExG$ssa,ExG$gssa,separate = T) -->
<!--     #} -->
<!--     for(i in input$disp_ssa){ -->
<!--       tmp=merge(tmp, ExG$rssa[,i]) -->
<!--     } -->
<!--     Disp$orig.ssa=tmp -->
<!--   } -->

<!--   ## Check if alpha band is already displayed, not clean -->
<!--   test_q1=(!any(grepl("Alp",colnames(Disp$orig.disp))) & "Bandpower" %in% input[["disp_event"]])| -->
<!--       (any(grepl("Alp",colnames(Disp$orig.disp))) & !("Bandpower" %in% input[["disp_event"]])) -->

<!--   # Check not implemented -->
<!--   # test_q2=(all(graph_data$EEG %in% colnames(Disp$orig.disp)) & !("Raw Signal" %in% input$disp_event))| -->
<!--   #               (!all(graph_data$EEG %in% colnames(Disp$orig.disp)) & ( "Raw Signal" %in% input$disp_event)) -->

<!--   if(test_q1|redat){ -->
<!--     # if(input$clust_disp){} -->
<!--     redat=T -->
<!--     tmp=Disp$orig.ssa -->
<!--     # if("Raw Signal" %in% input$disp_event){ -->
<!--     #   tmp=merge(tmp,ExG$ts[,unlist(lapply(strsplit(colnames(Disp$orig.chan),"Filtered"),function(x)x[[2]]))])   } -->
<!--   if("Bandpower" %in% input$disp_event){tmp=merge(tmp,ExG$bandpower)} -->
<!--     Disp$orig.disp=tmp -->
<!--   } -->

<!--   ## Update Resolution of data -->
<!--   if(range[2]>min(last(index(Disp$orig.disp)),Disp$resol[2])|| -->
<!--      range[1]<max(first(index(Disp$orig.disp)),Disp$resol[1])|| -->
<!--      resize||redat){ -->
<!--     ## if new data selection, dont change resolution borders -->
<!--     if(!redat){ -->
<!--       r1=max(first(index(Disp$orig.disp)),range[1]-10*d_range) -->
<!--       r2=min(last(index(Disp$orig.disp)),range[2]+10*d_range) -->
<!--     }else{ -->
<!--       r1=range[1] -->
<!--       r2=range[2] -->
<!--     } -->
<!--     redat=F -->
<!--       #Seconds down to full -->
<!--     if(Disp$sight=="detail"){ -->
<!--       if(r1!=first(index(Disp$orig.disp))){ -->
<!--         ## downsample out of scope to minutes, rest complete -->
<!--           tmp=rbind( -->
<!--             downsample(window(Disp$orig.disp,start=first(index(Disp$orig.disp)),end=r1),60*ExG$srate*5), -->
<!--             window(Disp$orig.disp,start=r1,end=r2)) -->
<!--       }else tmp=window(Disp$orig.disp,start=r1,end=r2) -->
<!--       if(r2!=last(index(Disp$orig.disp))){ -->
<!--           tmp=rbind(tmp, -->
<!--           downsample(window(Disp$orig.disp,start=r2,end=last(index(Disp$orig.disp))),ExG$srate*60*5))} -->
<!--       } -->
<!--         # Minutes , down to seconds -->
<!--     if(Disp$sight=="time"){ -->
<!--         if(r1!=first(index(Disp$orig.disp))){ -->
<!--           ## downsample out of scope to minutes, rest to seconds -->
<!--           tmp=rbind( -->
<!--               downsample(window(Disp$orig.disp,start=first(index(Disp$orig.disp)),end=r1),ExG$srate), -->
<!--               downsample(window(Disp$orig.disp,start=r1,end=r2),ExG$srate)) -->
<!--           }else tmp=downsample(window(Disp$orig.disp,start=r1,end=r2),ExG$srate) -->
<!--           if(r2!=last(index(Disp$orig.disp))){ -->
<!--             tmp=rbind(tmp, -->
<!--             downsample(window(Disp$orig.disp,start=r2,end=last(index(Disp$orig.disp))),ExG$srate))} -->
<!--     } -->
<!--       # hours down to minutes -->
<!--       # if(Disp$sight=="bird"){ -->
<!--       #   if(a!=first(index(Disp$orig.disp))){ -->
<!--       #       tmp=rbind( -->
<!--       #         downsample(window(Disp$orig.disp,start=first(index(Disp$orig.disp)),end=a),250*60*10), -->
<!--       #         downsample(window(Disp$orig.disp,start=a,end=b),250*60)) -->
<!--       #       }else{ -->
<!--       #           tmp=downsample(window(Disp$orig.disp,start=a,end=b),250*60) -->
<!--       #         } -->
<!--       #     if(b!=last(index(Disp$orig.disp))){ -->
<!--       #       tmp=rbind(tmp, -->
<!--       #       downsample(window(Disp$orig.disp,start=b,end=last(index(Disp$orig.disp))),250*60*10)) -->
<!--       #       } -->
<!--       # } -->
<!--       Disp$resol=c(r1,r2) -->
<!--       ExG$disp=tmp -->
<!--   } -->
<!--     }else{ -->
<!--       Sys.sleep(5) -->
<!--        Disp$newfile=F -->
<!--      } -->
<!-- }) -->
<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- if(shiny_running()){ -->
<!--   downloadButtonRmd("downloadReport",label="Download PDF") -->
<!-- } -->

<!-- if(shiny_running() ){ -->
<!-- output$downloadReport <- downloadHandler( -->
<!--   filename = function() { -->
<!--     paste('MentaLab', sep = '.', PDF = 'pdf') -->
<!--   }, -->
<!--   content = function(file){ -->
<!--     file.copy(paste0(mainDir,"/Dashboard.Rmd"), -->
<!--               paste0(mainDir,"/Report.Rmd"), overwrite = TRUE) -->
<!--     # nok=isolate(ExG$stages) -->
<!--     EXG<<-list() -->
<!--     EXG$stages=ExG$stages -->
<!--     EXG$df_res=ExG$df_res -->
<!--     EXG$spindles=ExG$spindles -->
<!--     EXG$hrv=ExG$hrv -->
<!--     EXG$summ=ExG$summ -->
<!--     out=rmarkdown::render(paste0(mainDir,"/Report.Rmd"), pdf_document(),runtime="static") -->
<!--     file.rename(out, file) -->
<!--   })} -->

<!-- ``` -->